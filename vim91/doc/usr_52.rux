*usr_52.txt*	для Vim version 9.1		   редакция от 09 июн 2024 г.

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

		    Создание крупных подключаемых модулей

Когда подключаемый модуль выполняет нечто большее, чем простое распознавание
типа файла, то, соответственно, увеличивается объём и сложность программного
кода такого модуля. В данной главе даются рекомендации по оптимизации загрузки
подобных модулей, а также как рационально разнести объёмные модули на
логические части по отдельным файлам, чтобы облегчит их обслуживание и
модификацию.

|52.1|	Экспорт и импорт
|52.2|	Автозагрузка
|52.3|	Автозагрузка без команд import и export
|52.4|	Другие возможные механизмы
|52.5|	Включение Vim9 в ранних командных файлах
|52.6|	Примеры командных файлов Vim9: comment package, highlight-yank plugin

  Следующая глава «Установка редактора Vim», |usr_90.txt|.
 Предыдущая глава «Создание подключаемых модулей редактора», |usr_51.txt|.
       Содержание, |usr_toc.txt|.

=============================================================================
*52.1*	Экспорт и импорт

Новая версия языка программирования |Vim9| была разработана для сокращения
и облегчения работы при создании сложных объёмных командных файлов Vim. Она
больше похожа на другие интерпретируемые языки, особенно на язык TypeScript.
Кроме того функции компилируются в промежуточные инструкции, которые позволяют
повысить быстроту выполнения программного кода. Это значительно ускоряет,
порой до 100 раз, работу программного кода Vim9.

Основная идея заключается в том, что командный файл содержит элементы, которые
используются только внутри этого командного файла, и экспортируемые элементы,
которые могут использоваться импортирующими их командными файлами. Такая
организация даёт чёткое представление, что и где будет определено в
программном коде.

Начнём мы с простого примера командного файла, который экспортирует одну
функцию и имеет одну внутреннюю (приватную) функцию.
>
	vim9script

	export def GetMessage(count: string): string
	   var nr = str2nr(count)
	   var result = $'To {nr} we say '
	   result ..= GetReply(nr)
	   return result
	enddef

	def GetReply(nr: number): string
	  if nr == 42
	     return 'yes'
	  elseif nr == 22
	     return 'maybe'
	  else
	     return 'no'
	  endif
	enddef
<
Начальная команда `vim9script` является обязательной, так как команда
`export` поддерживается только в языке |Vim9|.

Строки кода `export def GetMessage(...` начинаются с команды `export`, и это
означает, что функция «GetMessage» может быть вызвана другим командным файлом.
В строках же кода `def GetReply(...` нет команды `export` что говорит о том,
что данная функция является локальной функция командного файла и может быть
использована только для целей этого программного кода.

Несколько слов о командном файле в который будет импортирован вышеприведённый
программный код. Для данного примера мы использовали разместили наши командные
файлы таким образом, который обеспечивает работу командного файла в каталоге
«pack»:
    .../plugin/theplugin.vim ~
    .../lib/getmessage.vim ~

Такая конфигурация предполагает, что каталоги, обозначенные как «...», являются
частью списка значений параметра 'runtimpeth', и редактором Vim будет выполнен
поиск модуля в каталоге «plugin», где находится модуль «theplugin.vim». Учтите,
что редактор не распознаёт, и не проверяет каталог «lib», так что в этом
каталоге могут быть размещены любые командные файлы.

Программный код, приведённый выше, экспортирующий функцию GetMessage()
находится в командном файле по маршруту «lib/getmessage.vim», а вот сама
функция GetMessage() определена в командном файле «plugin/theplugin.vim»
>
	vim9script

	import "../lib/getmessage.vim"
	command -nargs=1 ShowMessage echomsg getmessage.GetMessage(<f-args>)
<
Команда `import` в данном случае оперирует относительным маршрутом,
начинающимся с символов «../», что подразумевает переход на один уровень выше
в иерархии каталогов. Для чтения других типов маршрутов, см. команду ":import"

Что же опробуем команду, которую предоставляет нам этот модуль:
>
	ShowMessage 1
<    Числу 1 ответим мы — решительное «нет» ~
>
	ShowMessage 22
<    Числу 22 ответим мы — возможно, что и «да» ~

Обратите внимание на следующий момент, функция GetMessage() всегда
предваряется наименованием импортируемого командного файла «getmessage».
Именно это позволяет для каждой импортируемой функции определить из какого
командного файла она была импортирована. Соответственно, если потребуется
импортировать несколько командных файлов, то в каждом из них можно определить
функцию, подобную GetMessage()
>
	vim9script

	import "../lib/getmessage.vim"
	import "../lib/getother.vim"
	command -nargs=1 ShowMessage echomsg getmessage.GetMessage(<f-args>)
	command -nargs=1 ShowOther echomsg getother.GetMessage(<f-args>)
<
В случае, если наименование импортированного командного файла превышает
ожидаемую длину его имени, или требуется использовать его во множестве местах,
допускается сократить это название до приемлемой длины, указав аргумент «as».
Примере,
>
	import "../lib/getmessage.vim" as msg
	command -nargs=1 ShowMessage echomsg msg.GetMessage(<f-args>)


ПОВТОРНЫЙ ВЫЗОВ

Но всегда имейте в виду, что импортированный код из «lib/getmessages.vim»
будет вызван только один раз. При повторном вызове этой функции он будет
пропущен, так как элементы выполняющие этот код уже были созданы. Неважно где
происходит вызов импорта, в другом командном файле или в том же самом, который
был вызван повторно.

Это может быть эффективно при запуске модуля, но при дальнейшей разработке
модуля это означает, что изменения в файле «lib/getmessage.vim» после вызова
этой функции не будут иметь никакого эффекта. Чтобы изменения возымели
эффект, необходимо завершение работы редактора Vim повторный перезапуск.
Причина таких действий кроется в том, что элементы (переменные и т. п.)
определённые в программном коде, могут быть использованы в скомпилированной
функции, а повторное импортирование кода может привести к сбою этих функций.


ПРИМЕНЕНИЕ ГЛОБАЛЬНЫХ ЗНАЧЕНИЙ

Иногда возникает необходимость использовать глобальные переменные или функции,
чтоб иметь возможность воспользоваться ими в иных модулях или программном коде.
Одним из примеров этого является глобальных переменная, которая передаёт общие
настройки модуля. Чтобы избежать влияние других модулей на такие переменные,
используйте приставку, коротая вряд ли будет применяться где‐то ещё.
Например, если модуль называется «mytags», то это будет уникальной приставкой
>
	g:mytags_location = '$HOME/project'
	g:mytags_style = 'fast'
<
==============================================================================
*52.2*	Автозагрузка

После того, как объёмный командный файл будет разделён на логические блоки,
все строги будут загружены и выполнены только в момент использования модуля.
Каждая команда `import` загружает импортированный код лишь для того, чтобы
найти определённые в нём элементы. Данный подход, безусловно, хорош для
раннего обнаружения ошибок, тем не менее это занимает время при запуске
редактора, которое тратиться впустую, если функциональность используется редко.

Решением этого является возможность отложить загрузку кода командой `import`
выполоть до того момента, пока он не понадобится на самом деле. Для этого нужно
сделать в приведённом выше примере «plugin/theplugin.vim» одно такое изменение
>
	import autoload "../lib/getmessage.vim"
<
В остальной части программного кода ничего менять не нужно. Но стоит учесть,
что типы переменных при этом проверяться не будут. И даже существование
функции GetMessage() не будет проверяться до тех пор, пока она не будет
вызвана. В этом случае возникает коллизия, что является приоритетным. Ранее
обнаружение ошибок или вызов модуля на ранней стадии загрузки. Тем не менее
есть некий компромисс: добавить в последующем аргумент «autolad», когда
убедитесь, что всё работает так как ожидается.


КАТАЛОГ AUNOLOAD

Другим вариантом решения возможно использование автозагрузки командного файла,
не являющемся абсолютным или относительным маршрутом к загружаемому модулю.
>
	import autoload "monthlib.vim"
<
Это приведёт к поиску командного файла «monthlib.vim» в каталогах автозагрузки
перечисленных в списке значений параметра 'runtimepath'. В UNIX-подобных
системах одним из каталогов часто является «~/.vim/autoload». Поиск также
будет выполняться и в каталоге «start», указанного в параметре 'packpath'.

Главное преимущество данного варианта заключается в том, что этот скрипт
можно использовать с другими скриптами. Важно убедиться, что наименование
командного файла уникально, поскольку в редакторе Vim поиск будет производится
по всем каталогам «autolоad» присутствующие в значении параметра
'runtimepath'. И если для установки модулей используется диспетчер модулей, то
возможно, что в параметр 'runtimepath' будут добавлены каталоги, каждый из
которых имеет подкаталог «autoload».

Без указания аргумента «autoload»
>
	import "monthlib.vim"
<
В редакторе Vim будет выполняться поиск командного файла «monthlib.vim» в
каталогах импорта из списка значений параметра 'runtimepath'. Обратите
внимание, что добавление или удаление аргумента «autoload» изменяется место
поиска нахождения командного файла. При указании относительного или
абсолютного маршрута файла, поиск местоположение не изменяется.

==============================================================================
*52.3*	Автозагрузка без команд import и export

						*write-library-script*
Механизм, существовавший до введения команд `import` и  `export` по‐прежнему
доступен и для некоторых он может быть более полезным и простым. Идея этого
способа заключается в том, что вызов функции происходит по специально
сформированному названию. В последующем эта функция включается в командный
файл автозагрузки. Мы будем называть такой командный файл библиотечным
командным файлом.

Этот механизм основан на формирование наименования функции через символы '#'.
>
	mylib#myfunction(arg)
<
В редакторе Vim разбор наименование функции выполняется по включаемым символам
'#' и, если оно ещё не определено, выполняется поиск командного файла
«autoload/mylib.vim» в списке значений параметра 'runtimepath'. В этом
командном файле должна быть определена функция «mylib#myfunction()». Очевидно,
что запись «mylib» перед символом '#' используется как наименование командного
файла с добавлением расширения «.vim».

Допускается определение множества других функций в командном файле
«mylib.vim». Но обязательным условием при определении функции должно быть то,
что наименование функции должна содержать название командного файла, в котором
эта функция определена перед символом '#'. В противном случае редактор не смог
бы определить какой командный файл требуется загружать. В этом и состоит
основное отличие от механизма импорта/экспорта.

Если создаётся много библиотечных командных файлов, возможно, было бы разумно
размещать их в подкаталогах. Пример,
>
	netlib#ftp#read('somefile')
<
В этом примере наименование командного файла берётся из названия перед
последним символом '#'. Символ '#' в середине названия заменяется наклонной
чертой и в конце добавляется расширение «.vim». Таким образом мы получим
следующую иерархию каталогов «netlib/ftp.vim». В UNIX-подобной системе такой
библиотечный командный файл мог бы располагаться, например, здесь —

    ~/.vim/autoload/netlib/ftp.vim ~

В котором функция определена примерно так:
>
	def netlib#ftp#read(fname: string)
		#  Read the file fname through ftp
	enddef
<
Обратите внимание, что наименование с которым определена функция в точности
совпадает с названием, используемым для вызова функции. А часть перед
последним символом '#' в точности совпадает с подкаталогом и командным файлом.

Можно использовать точно такой же механизм и для переменных
>
	var weekdays = dutch#weekdays
<
Этот программный код вызовет загрузку командного файла «autoload/dutch.vim»,
в котором будут примерно такие строки:
>
	var dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',
		\ 'donderdag', 'vrijdag', 'zaterdag']
<
Расширенную информацию можно прочитать здесь — |autoload|.

==============================================================================
*52.4*	Другие возможные механизмы
						*write-plugin-quickload*
В некоторых ситуациях бывает невозможным использование нескольких файлов для
модуля и возникает необходимость хранить весь программный код в одном файле.
На этот случай существует механизм, который предотвращает медленный запуск
командного файла, а определяет только небольшую часть для загрузки и
откладывает выполнение остальной часть до того момента, когда она будет
фактически использована.

Основная идея заключается в том, что модуль загружается дважды. В первый
проход определяются пользовательские команды и клавиатурные команды, которые
предоставляют функциональность. А во второй проход определяются функции,
которые и реализуют эту функциональность.

Может показаться удивительным, что быстрая загрузка означает повторный запуск
модуля. Мы имеем в виду, что в первый раз он загружается быстро, откладывая
основную часть программного кода на второй раз, который происходит только
тогда, когда он действительно будет использоваться. Когда постоянно
используется рабочая функциональность командного файла, это действительно
становится медленнее.

Для этого будет использована автокоманда по событию FuncUndefined. Это
работает несколько иначе, чем функциональность |autoload|, описанная выше.

Следующий пример покажет, как это делается:
>
	" Vim global plugin for demonstrating quick loading
	" Last Change:	2005 Feb 25
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" License:	This file is placed in the public domain.

	if !exists("s:did_load")
		command -nargs=* BNRead  call BufNetRead(<f-args>)
		map <F19> :call BufNetWrite('something')<CR>

		let s:did_load = 1
		exe 'au FuncUndefined BufNet* source ' .. expand('<sfile>')
		finish
	endif

	function BufNetRead(...)
		echo 'BufNetRead(' .. string(a:000) .. ')'
		" read functionality here
	endfunction

	function BufNetWrite(...)
		echo 'BufNetWrite(' .. string(a:000) .. ')'
		" write functionality here
	endfunction
<
При первой загрузке модуля значение переменной «s:did_load» не установлено. И,
соответственно, будут выполнены команды расположенные между командой ":if" и
":endif" которые заканчиваются командой |:finish|, таким образом остальная
часть командного файла не будет выполняться.

При второй загрузке модуля значение переменной «s:did_load» уже установлено.
И, соответственно, будут выполняться команды после команды ":endif", где и
определяются функции BufNetRead() и BufNetWrite().

При добавлении этого модуля в каталог «plugin», он будет загружен при запуске
редактора Vim. Вот последовательность событий, которые будут происходить:

1. Вовремя загрузки модуля при запуске редактора будет определена
   пользовательская команда BNRead и назначена клавиатурная команда на клавишу
   <F19>. А также будет определена автокоманда по событию |FuncUndefined|. И
   далее по команде ":finish" происходит преждевременное завершение командного
   файла.

2. Пользователь набирает команду BNRead или нажимает клавишу <F19>. В этот
   момент будут попытка вызова функции BufNetRead() или BufNetWrite().

3. Редактор Vim не в состоянии найти эти функции и срабатывает автокоманда по
   событию |FuncUndefined| поскольку шаблон соответствует вызываемой функции,
   будет выполнена команда ":source fname". Аргумент «fname» будет
   соответствовать наименованию модуля, независимо от того, где он находится,
   так как это наименование получено при расширении спецсимвола <sfile>
   (см. |expand()|).

4. Модуль будет снова загружен, а так как уже существует переменная
   «s:did_load», то будет выполнено определение функций.

Обратите внимание, что функции, которые загружаются при повторном вызове
соответствуют шаблону автокоманды по событию |FuncUndefined|. И должна быть
чёткая уверенность, что ни один другой командный файл не определяет функции,
соответствующие этому шаблону.

==============================================================================
*52.5*	Включение Vim9 в ранних командных файлах	*source-vim9-script*

Командных файлов написанных с использованием синтаксиса предыдущей версии языка
VimL очень и очень много. А это значит, что возникнут ситуации, когда в таких
командных файлов потребуется использовать элементы новой версии |Vim9|.
Допустим, инициализировать модуль в файле инициализации «vimrc». И лучший
способ для этого — использовать команду `:import`. Например,
>
	import 'myNicePlugin.vim'
	call myNicePlugin.NiceInit('today')
<
При исполнении этих команд будет найдена экспортируемая функция NiceInit() в
командном файле Vim9 и сделает её доступной локально для командного файла как
элемент «myNicePluginNiceInit». Команда ":import" всегда использует
пространство имён командных файлов, даже если не указана приставка «s:». Если
командный файл «myNicePlugin.vim» уже исполняется, то повторного запуска не
потребуется.

Помимо того, что мы избегаем помещение каких‐либо элементов в глобальное
пространство имён (где конфликты названий могут привести к непредвиденным
ошибкам), это также гарантирует, что командный файл создаётся только один
раз, независимо от того, сколько раз из него будут импортировано элементов.

В некоторых случаях, например, для проверок, допускается использовать исходный
код командного файла Vim9. Но тогда будут доступны только глобальные элементы.
Это означает, что командный файл Vim9 должен использовать уникальные
наименования для этих глобальных элементов. Пример,
>
	source ~/.vim/extra/myNicePlugin.vim
	call g:NicePluginTest()
<
==============================================================================
*52.6*	Примеры командных файлов Vim9: comment package, highlight-yank plugin


COMMENT PACKAGE

В поставку редактора Vim включён пакет модуля комментариев, который полностью
написан с использованием синтаксиса Vim9. |comment-install|
Данный пакет расположен по в каталоге «$VIMRUNTIME/pack/dist/opt/comment/»,
где с ним и можно ознакомиться.

HIGHLIGHT YANK PLUGIN

Ниже дан пример подсветки скопированной области. В этом примере используется
функция |getregionpos()|, доступная начиная с версии редактора Vim 9.1.0446.

Скопируйте следующий программный код в новый командный файл и поместите этот
файл в каталог «plugin». Этот модуль будет загружен при следующем запуске
редактора Vim.   |add-plugin|
>
	vim9script

	def HighlightedYank(hlgroup = 'IncSearch', duration = 300, in_visual = true)
	  if v:event.operator ==? 'y'
	    if !in_visual && visualmode() != null_string
	      visualmode(1)
	      return
	    endif
	    var [beg, end] = [getpos("'["), getpos("']")]
	    var type = v:event.regtype ?? 'v'
	    var pos = getregionpos(beg, end, {type: type})
	    var end_offset = (type == 'V' || v:event.inclusive) ? 1 : 0
	    var m = matchaddpos(hlgroup, pos->mapnew((_, v) => {
	      var col_beg = v[0][2] + v[0][3]
	      var col_end = v[1][2] + v[1][3] + end_offset
	      return [v[0][1], col_beg, col_end - col_beg]
	    }))
	    var winid = win_getid()
	    timer_start(duration, (_) => m->matchdelete(winid))
	  endif
	enddef

	autocmd TextYankPost * HighlightedYank()
<
==============================================================================

Следующая глава «Установка редактора Vim», |usr_90.txt|.
Об авторских правах на документацию см. |manual-copyright|.

© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

 vim:tw=78:ts=8:ft=help:norl:

