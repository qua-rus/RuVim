*usr_44.txt*	для Vim version 9.1		   редакция от 06 мая 2017 г.

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

		   Собственные правила подсветки синтаксиса


В комплект поставки редактора Vim входят файлы с правилами подсветки
синтаксиса для пары сотен типов файлов. Но если вдруг приходится редактировать
тип файла для которого отсутствует готовое решение, в этой главе
рассказывается о том, что делать в таких случаях, и как подготовить файл
разбора и подсветки синтаксиса. Также смотрите |:syn-define| в справочнике.

|44.1|	Основные команды для синтаксиса
|44.2|	Ключевые слова
|44.3|	Сопоставления
|44.4|	Синтаксические области
|44.5|	Вложенные элементы
|44.6|	Последовательный разбора синтаксиса
|44.7|	Прочие аргументы
|44.8|	Коллекции
|44.9|	Включение других файлов с правилами синтаксиса
|44.10|	Синхронизация
|44.11|	Подключение файла синтаксиса к редактору Vim
|44.12|	Общий формат файла синтаксиса

 Следующая глава «Региональные настройки», |usr_45.txt|.
Предыдущая глава «Работа с различными типами файлов», |usr_43.txt|.
      Содержание, |usr_toc.txt|.

==============================================================================
*44.1*	Основные команды для синтаксиса

Можно сэкономить время и силы, если воспользоваться уже существующим файлом
разбора синтаксиса в качестве отправной точки. Постарайтесь найти файл с
правилами синтаксиса в каталоге «$VIMRUNTIME/syntax» для языка, который похож
на используемый в новом типе файла. Кроме того, это поможет понять общее
устройство файлов с правилами разбора и подсветки синтаксиса.

Давайте начнём с самых простых команд. Прежде чем приступим к описанию новых
правил разбора синтаксиса, нам лучше убрать любые уже действующие определения
>
	:syntax clear
<
Эта команда не требуется для конечного результата, но сильно поможет в наших
экспериментах.

В этой главе также будет ещё несколько упрощений. Прочитайте эту главу до
конца, чтобы понять все детали описания правил синтаксиса, особенно если
хотите создать файл разбора синтаксических правил, который будет
использоваться другими людьми.


ПЕРЕЧЕНЬ ЗАДАННЫХ ЭЛЕМЕНТОВ СИНТАКСИСА

Для просмотра текущих синтаксических правил, используйте команду
>
	:syntax
<
Будет выведен перечень всех определённых в данный момент синтаксических
элементов. Это полезно при экспериментах с новыми правилами подсветки
синтаксиса. Для каждого элемента также будет показан цвет, которым он
выделяется в тексте, что также помогает быстро разобраться что есть что.

Чтобы посмотреть элементы из определённой синтаксической группы, используйте
команду
>
	:syntax list {название-группы}
<
По этой же команде можно получить перечень имеющихся коллекций (объясняется в
параграфе |44.8|). Для этого добавьте к названию приставку в виде символа '@'.


РЕГИСТР СИМВОЛОВ

Некоторые языки программирования не различают регистр символов, например
Pascal. Другие же языки, например Си, учитывают регистр символов. А значит
в правилах следует указывать с каким именно случаем мы имеем дело.
>
	:syntax case match
<
Аргумент «match» означает, что при разборе синтаксиса будет учитываться
строгое соответствие регистру символов в элементах синтаксиса. Таким образом
ключевое слово "int" будет различаться от "Int" и "INT".
>
	:syntax case ignore
<
При использовании аргумента «ignore» регистр символов не учитывается —
"Procedure", "PROCEDURE" и "procedure" указывают на один и тот же
синтаксический элемент.

Команды ":syntax case" могут быть заданы в любом месте файла правил синтаксиса
и оказывают влияние только на те команды, которые следуют после этой команды.
В большинстве случаев достаточно указать только одну команду ":syntax case"
в файле синтаксических правил; однако, если язык для которого создаются
синтаксические правила, содержит как регистрозависимые, так и
регистронезависимые элементы, то необходимо указывать команды ":syntax case"
в файле так, как это требует синтаксис этого языка.

==============================================================================
*44.2*	Ключевые слова

Основными синтаксическими элементами в правилах являются ключевые слова. Для
определения ключевого слова используется такая форма
>
	:syntax keyword {группа} {ключевое-слово} ...
<
Аргумент {группа} — это название синтаксической группы. Посредством команды
":highlight" именно к этому названию {группы} выполняется привязка того или
иного цвета для возможности подсветки синтаксиса.
Само ключевое слово задаётся через аргумент {ключевое-слово}. Вот несколько
примеров:
>
	:syntax keyword xType int long char
	:syntax keyword xStatement if then else endif
<
В этих примерах используются группы «xType» и «xStatement». По установленному
соглашению, название каждой группы начинается с типа файла, для которого
определяется данная группа. В нашем примере определены группы для типа файла
«x». В правилах синтаксиса для сценариев оболочки csh мы использовали бы
группы вроде «cshType». Таким образом, приставка в наименовании соответствует
значению параметра 'filetype'.

Наши примеры позволят выделять слова «int», «long» и «char» одним способом,
а слова «if», «then», «else» и «endif« — другим. Теперь нам осталось только
связать названия групп «x» со стандартными группами редактора Vim.
Это выполняется при помощи следующих команд:
>
	:highlight link xType Type
	:highlight link xStatement Statement
<
Теперь в редакторе Vim слова из группы «xType» будет подсвечивать тем же
цветом, как и стандартная группа «Type», а слова из группы «xStatement» как и
стандартная группа «Statement». Наименования стандартных групп перечислены в
|group-name|.


ОСОБЫЕ КЛЮЧЕВЫЕ СЛОВА

Символы, присутствующие в ключевом слове, должны быть определены в значении
параметра 'iskeyword'. Если присутствуют символы, которые не указаны в
значении этого параметра, то такое слово не будет распознано как ключевое.
А в редакторе Vim не предусмотрено никаких предупреждений о таких ситуациях.

В нашем гипотетическом языке x в ключевых словах может присутствовать символ
'-'. Для того, чтобы они распознавались как ключевые слова, мы сообщим об этом
редактору Vim по средством следующих команд:
>
	:setlocal iskeyword+=-
	:syntax keyword xStatement when-not
<
Использование команды ":setlocal" позволяет менять значение параметра
'iskeyword' только для текущего буфера. В то же время, изменение значения
этого параметра также влияет на поведение таких команд, как `w` и `*`. Если
это не желательно, то вместо задания ключевого слова потребуется определение
сопоставления (объясняется в следующем параграфе). Но лучшим вариантом будет
использование команды
>
	syntax iskeyword =-
<
Детали объясняются здесь — |:syn-iskeyword|.

Язык x позволяет также использовать сокращения ключевых слов. Например, «next»
можно сокращать до «n», «ne» или «nex». Такое ключевое слово поддерживающее
сокращение можно определить командой
>
	:syntax keyword xStatement n[ext]
<
Ключевые слова всегда сопоставляются только с полным словом, так что это не
будет распространяться на слово «nextone».

==============================================================================
*44.3*	Сопоставления

Попробуем теперь определить немного более сложный синтаксический элемент.
Допустим, хотелось бы различать в тексте обычные наименования переменных.
Чтобы это реализовать, нам потребуется задействовать сопоставление. Применив
следующую команду мы создадим группу, в которую попадают все слова, состоящие
из строчных букв, т. е. названия переменных
>
	:syntax match xIdentifier /\<\l\+\>/
<
    Примечание.
    Определение ключевых слов имеет наивысший приоритет перед любым другим
    синтаксическим элементом. Поэтому, в нашем примере слова «if», «then»
    и т. д. будут определены как ключевые слова, как это объявлено по команде
    ":syntax keyword", несмотря на то, что они попадают под действие шаблона
    для группы xIdentifier.

Завершающий аргумент команды сопоставления — это шаблон поиска, подобный
такому же, которые используется в командах поиска. Поисковый шаблон
ограничивается парой символов / и /, как это делается, например, в команде
":substitute". Допускается применение любых других парных символов, например,
+ и + или " и ".

Теперь давайте определим сопоставление для комментария. В языке x комментарием
считается всё, что угодно, от символа '#' и до конца строки
>
	:syntax match xComment /#.*/
<
Поскольку можно использовать любой допустимый шаблон для поиска сопоставления,
то можно определить подсветку разнообразных и более точных синтаксических
конструкций, применяя различные шаблоны. Подробнее о шаблонах сопоставления
см. здесь — |pattern|.

==============================================================================
*44.4*	Синтаксические области

В нашем гипотетическом языке x текстовые строки заключены в двойные кавычки
("). Чтобы подсвечивать такие строки, нам потребуется объявить синтаксическую
область. Мы должны указать начало области (первая двойная кавычка) и окончание
области (последняя двойная кавычка). Определение такой области выглядит так:
>
	:syntax region xString start=/"/ end=/"/
<
Директивы «start» и «end» задают шаблоны, которые служат для определения
начала и окончания области. Но вот как это будет работать со строками, которые
выглядят так, как показано ниже?

    "Строка с двойной кавычкой (\") внутри" ~

В данном случае возникает некоторая неопределённость — ведь двойная кавычка
в середине этой строки будет распознана как окончание синтаксической области.
Значит нам надо указать редактору, что не нужно обращать внимание на
экранированный символ двойной кавычки внутри текстовой строки.
И это делается через указание директивы «skip» (пропустить)
>
	:syntax region xString start=/"/ skip=/\\"/ end=/"/
<
Обратите внимание, что удвоение наклонной черты соответствует одинарной
наклонной черте, поскольку сама наклонная черта в шаблонах нуждается в
экранировании.

Порой возникает вопрос, в каких случаях использовать сопоставления, а когда
лучше применять определение синтаксической области?
Основное различие между ними состоит в том, что в сопоставлении используется
только один шаблон, который должен в точности совпадать с образцом. А вот
действие области же начинается как только встречается совпадение с шаблоном,
указанным в директиве «start». Будет ли найдено совпадение с шаблоном в
директиве »end» или нет — не имеет никакого значения. Поэтому, если для
элемента синтаксиса может отсутствовать соответствие шаблону в директиве
«end», то в этом случае использовать область нельзя. В остальном, определение
области синтаксиса, как правило, намного проще и внутри такой области намного
проще находить вложенные элементы, о чём рассказывается в следующем параграфе.

==============================================================================
*44.5*	Вложенные элементы

Посмотрите на этот комментарий

    %Get input  TODO: Skip white space ~

Возможно, было бы лучше, если бы слово «TODO» было как‐то выделено, например,
подсвечено жёлтым цветом, хотя оно и находится внутри комментария, который
подсвечивается синими буквами. Чтобы это реализовать в редакторе Vim,
необходимо определить следующие группы синтаксиса:
>
	:syntax keyword xTodo TODO contained
	:syntax match xComment /%.*/ contains=xTodo
<
В первой команде мы использовали аргумент «contained», который указывает, что
данный элемент будет обрабатываться только если он является частью другого
синтаксического элемента. И вот в следующей команде имеется директива
«contains=xTodo». Которая как раз и сообщает, что в этом синтаксическом
элементе может присутствовать, а может и не присутствовать, элемент «xTodo».
При обработке этих команд строка комментария будет распознана как элемент
«xComment» и подсвечена синим цветом, но слово «TODO» внутри комментария
относится к группе «xTodo» и будет подсвечено жёлтым цветом (для этого мы
отдельно настроили подсветку для «xTodo»).


РЕКУРСИВНЫЕ ВЛОЖЕНИЯ

В языке x блок программного кода заключается в фигурные скобки. В свою очередь
такой программный блок также может содержать другой программный блок.
Такие синтаксические элементы могут быть определены примерно такой командой
>
	:syntax region xBlock start=/{/ end=/}/ contains=xBlock
<
Например, представьте, что у вас есть такой текст:

    while i < b { ~
	    if a { ~
		    b = c; ~
	    } ~
    } ~

Синтаксический элемент «xBlock» будет применён в первой строке начиная с
первой фигурной скобки '{'. При дальнейшем разборе во второй строке
обнаруживается вторая открывающая фигурная скобка '{', а у нас уже действует
синтаксический элемент «xBlock», который может включать такой же
синтаксический элемент «xBlock». И именно он начинает применяться с этой
второй фигурной скобке. Выражение «b = c;» также находится внутри второго
блока и обрабатывается вложенным элементом «xBlock». Далее обнаруживается
закрывающая фигурная скобка '}', а поскольку у нас здесь действует второй,
вложенный, синтаксический элемент «xBlock», то эта скобка будет обработана
именно им и он завершит свою работу, т. к. это является шаблоном окончания
действия синтаксической области. И, наконец, обнаруживается ещё одна
закрывающая фигурная скобка '}', и уже она будет обработана первым, внешним,
синтаксическим элементом «xBlock», который после этого завершит свою работу.
Иными словами, области видимости внешних и внутренних синтаксических
элементов, как правило, не пересекаются и каждый такой синтаксический элемент
отрабатывается самостоятельно.


СЛЕДИТЕ ЗА СВОИМИ КОНЦАМИ

Посмотрите внимательно на следующие два определения:
>
	:syntax region xComment start=/%/ end=/$/ contained
	:syntax region xPreProc start=/#/ end=/$/ contains=xComment
<
Здесь задана синтаксическая область «xComment», началом которой определён
символ '%' и заканчивается это область в конце строки. Также задана
синтаксическая область «xPreProc», начало которой определена символом '#' и
она также продолжается до конца строки. Помимо этого синтаксическая область
«xPreProc» включает аргумент «contains=xComment», поскольку в строке с
директивой препроцессора может присутствовать комментарий. Похоже, что всё
правильно сделано. Но давайте посмотрим, как это будет работать на практике.

    #define X = Y  % Comment text ~
    int foo = 1; ~

А получается, что вторая строка также подпадает под действие синтаксической
области «xPreProc» и подсвечивается тем же цветом. Что же тогда случилось?
Ведь синтаксическая область должна заканчиваться в конце строки, как это
задано директивой «end=/$/».

Причина этой ситуации в синтаксической области «xComment», которая
обрабатывается для той же самой строки. Область начинается с символа '%' и
заканчивается в конце строки, но после обработки области «xComment»
продолжается обработка области «xPreProc», а так как признак конца строки уже
был обработан для «xComment», то область «xPreProc» продолжается на следующую
строку.

Чтобы избежать подобных казусов, когда включаемый синтаксический элемент
«съедает» конец строки, используйте аргумент «keepend». В этом случае будет
контролироваться окончание строки для включающего синтаксического элемента, а
включаемый элемент будет обрезаться там, где заканчивается включающий элемент.
>
	:syntax region xComment start=/%/ end=/$/ contained
	:syntax region xPreProc start=/#/ end=/$/ contains=xComment keepend
<

МНОЖЕСТВЕННОЕ ВКЛЮЧЕНИЕ ЭЛЕМЕНТОВ

Аргумент «contains» может быть использован для указания, что синтаксическая
область может включать все имеющиеся синтаксические элементы. Например,
>
	:syntax region xList start=/\[/ end=/\]/ contains=ALL
<
По этой команде будут включены в синтаксическую область «xList» любые другие
синтаксические элементы, в том числе и сама синтаксическую область «xList»,
за исключением, конечно, директивы «start=/\[/» данного элемента «xList»,
чтобы не создавать бесконечного цикла.

Также можно указать синтаксические группы, которые не будут включены в другую
синтаксическую группу. Например, по команде
>
	:syntax region xList start=/\[/ end=/\]/ contains=ALLBUT,xString
<
будут включены все элементы, кроме группы «xString». Значение TOP указывает на
включение всех элементов, которые не имеют аргумента «contained». А значение
CONTAINED, наоборот, используется для включения только элементов, определённых
с аргументом «contained». Подробнее см. |:syn-contains|.

==============================================================================
*44.6*	Последовательный разбора синтаксиса

В нашем языке x есть выражения вида

    if (condition) then ~

Было бы желательно визуально по разному выделить все три элемента выражения.
Но вот, «(condition)» и «then« могут также быть частью других выражений, где
они будет сопоставлена другой синтаксической группе. В данном примере это
можно сделать так:
>
	:syntax match xIf /if/ nextgroup=xIfCondition skipwhite
	:syntax match xIfCondition /([^)]*)/ contained nextgroup=xThen skipwhite
	:syntax match xThen /then/ contained
<
Аргумент «nextgroup» указывает на следующую синтаксическую группу, которая
будет выполнять разбор синтаксического элемента, что, однако, не является
обязательным. Если при последовательном разборе следующий элемент не подпадает
под указанную группу, то эти элементы просто пропускаются.
Например, имеется такой текст

    if not (condition) then ~

Слово «if» принадлежит группе «xIf». Дальнейший разбор выполняется следующей
синтаксической группой «xIfCondition», но поскольку слово «not» не входит в
указанную группу, то будет выполнена подсветка только слова «if» и разбор на
этом будет остановлен.

Аргумент «skipwhite» указывает, что пробелы и табуляция могут присутствовать
между элементами. Похожие аргументы: «skipnl» (позволяет использовать перенос
строки между элементами) и «skipempty» (позволяет использовать пустые строки).
Обратите внимание, что «skipnl» не пропускает пустую строку, после переноса
строки должно быть что-то, что соответствует синтаксическому элементу.

==============================================================================
*44.7*	Прочие аргументы

АРГУМЕНТ MATCHGROUP

При определении области будет подсвечивается вся область в согласно заданному
названием группы. Например, для подсветки текста в круглых скобках по правилам
группы «xInside», используется команда
>
	:syntax region xInside start=/(/ end=/)/
<
Теперь предположим, что нам требуется подсвечивать сами скобки как-то иначе.
Этого можно было бы добиться сложными командами для определения
соответствующих областей, но можно поступить намного проще и использовать
аргумент «matchgroup». Это позволяет выделять начало и конец области с помощью
другой группы подсветки (в данном случае мы используем группу «xParen»)
>
	:syntax region xInside matchgroup=xParen start=/(/ end=/)/
<
Аргумент «matchgroup» будет применяется к шаблонам определяющих начало и конец,
синтаксической области которые указаны в той же команде. В предыдущем примере
как начало, так и конец области подсвечиваются с помощью группы «xParen».
Чтобы подсвечивать конец области при помощи правил, определённых для группы
«xParenEnd» используйте такую команду
>
	:syntax region xInside matchgroup=xParen start=/(/
		\ matchgroup=xParenEnd end=/)/
<
Побочный эффект оказываемый аргументом «matchgroup» состоит в том, что
содержащиеся внутри элементы не включаются в соответствие для начала или конца
области. Это используется в примере для аргумента «transparent».


АРГУМЕНТ TRANSPARENT

В языке Си необходимо подсвечивать текст в скобках () после слова «while» не
так, как текст в скобках после слова «for». В обоих случаях внутри скобок
могут быть вложенные области текста в скобках, которые должны подсвечиваться
одинаково. Кроме того, необходимо убедиться, что подсветка области в ()
заканчивается на соответствующей скобке ). Вот как этого всего можно добиться:
>
	:syntax region cWhile matchgroup=cWhile start=/while\s*(/ end=/)/
		\ contains=cCondNest
	:syntax region cFor matchgroup=cFor start=/for\s*(/ end=/)/
		\ contains=cCondNest
	:syntax region cCondNest start=/(/ end=/)/ contained transparent
<
Теперь можно задать разные правила для подсветки групп «cWhile» и «cFor».
Элемент «cCondNest» может присутствовать в каждой из них, но при этом будет
подсвечиваться в соответствии с правилами подсветки для включающего его
элемента. Добиться этого позволяет аргумент «transparent».

Обратите внимание, что аргумент «matchgroup» указывает на ту же самую группу,
что и сам элемент. Зачем тогда пользоваться определением «matchgroup»? Всё
дело в том, что побочным эффектом определения «matchgroup» является то, что
включённые элементы в этом случае не будут найдены в соответствиях для начала
и конца области. Это позволяет избежать ситуации, при которой группа
«cCondNest» соответствует '(' сразу после слов «while» или «for». В противном
случае, эта группа захватила бы весь текст до соответствующей скобки ')'
и затем область бы продолжалась. А так группа «cCondNest» соответствует только
области после совпадения с первой скобкой '('.


СМЕЩЕНИЯ

Предположим, необходимо определить область текста между скобками () после
слова «if», но при этом не требуется включать в область ни слово «if», ни сами
скобки. Этого можно достичь при помощи смещений в шаблонах. Пример,
>
	:syntax region xCond start=/if\s*(/ms=e+1 end=/)/me=s-1
<
Смещение для шаблона start указано как «ms=e+1». Где «ms» — это начало
совпадения (Match Start). Так мы определяем смещение для начала соответствия.
Заметьте, что это отличается от обычного определения области, когда
соответствие начинается в точке начала шаблона. Выражение «e+1» указывает, что
область начинается со следующего символа после окончания совпадения шаблону.

Смещение для шаблона директивы «end» указано как «me=s-1». Где «me» — это
конец совпадения (Match End). Выражение «s-1» указывает, что область
начинается с предыдущего символ, т. е. символа, который предшествует шаблону
окончания области. В результате, в тексте

    if (foo == bar) ~

только выражение «foo == bar» будет подсвечиваться по правилам, определённым
для группы «xCond».

Подробнее о смещения читайте здесь — |:syn-pattern-offset|.


АРГУМЕНТ ONELINE

Аргумент «oneline» указывает на то, что область ограничена текущей строкой.
Например,
>
	:syntax region xIfThen start=/if/ end=/then/ oneline
<
определяет область, которая начинается со слова «if» и заканчивается словом
«then«, которые должны находится на одной строке.

    Примечание.
    При использовании аргумента «oneline» область начинается только тогда,
    когда в той же строке будет найдено совпадение шаблону директиве «end».
    Без использования аргумента «oneline» в редакторе Vim вообще не
    проверяется наличие соответствия шаблону в директиве «end», а просто
    начинает область, даже в тех случаях, когда соответствие шаблону директиве
    «end» вообще отсутствует в файле.


РАБОТА С ПРОДОЛЖАЮЩИМИСЯ СТРОКАМИ

Постепенно по ходу главы возможности и сложность наших правил увеличиваются.
Давайте определим группу для строки препроцессора. Строка начинается с
символа '#' в первом столбце и продолжается до конца строки. Но при этом
строка, которая заканчивается символом '\' указывает, что следующую за ней
строку следует считать продолжением текущей. Чтобы отразить продолжение строки
в правилах синтаксиса, введём такие определения:
>
	:syntax region xPreProc start=/^#/ end=/$/ contains=xLineContinue
	:syntax match xLineContinue "\\$" contained
<
И хотя группа «xPreProc» обычно соответствует только одной строке, но
содержащаяся внутри неё группа «xLineContinue» указывает, что возможно
продолжение действия области и на следующую строку. Например, заданные правила
позволяют правильно обработать обе следующие строк:

    #define SPAM  spam spam spam \ ~
		    bacon and spam ~

В данном случае всё происходит так, как нам требуется. Если же мы хотим иного
результата, то можно определить область только в одной строке при помощи
аргумента «excludenl» в шаблоне сопоставления с аргументом «contained».
Например, мы хотим подсветить слово «end» в группе «xPreProc», но только в
конце строки. Чтобы синтаксическая область «xPreProc» не продолжалась на
следующей строке, как это делает группа «xLineContinue», мы используем
аргумент «excludenl»:
>
	:syntax region xPreProc start=/^#/ end=/$/
		\ contains=xLineContinue,xPreProcEnd
	:syntax match xPreProcEnd excludenl /end$/ contained
	:syntax match xLineContinue "\\$" contained
<
Аргумент «excludenl» должен быть помещён перед шаблоном. Поскольку в группе
«xLineContinue» отсутствует аргумент «excludenl», соответствие этой группе
позволит продолжить группу «xPreProc» на следующей строке, как и раннее.

==============================================================================
*44.8*	Коллекции

По мере создания файла с правилами разбора синтаксиса в нём будут определено
достаточно большое количество синтаксических групп. Для упрощения их
использования и удобства управления этими группами, в редакторе Vim
предусмотрен механизм объединения синтаксических групп, который называется
коллекции.

Предположим, в нашем языке имеются синтаксические конструкции для циклов
«for», условных выражений «if», циклов «while» и функций. Каждая из них
содержит одни и те же синтаксические элементы — числа и переменные.
Мы определяем их таким образом:
>
	:syntax match xFor /^for.*/ contains=xNumber,xIdent
	:syntax match xIf /^if.*/ contains=xNumber,xIdent
	:syntax match xWhile /^while.*/ contains=xNumber,xIdent
<
Заметьте, что в каждом определении повторяется один и тот же аргумент
«contains=». Если потребуется добавить какой‐нибудь новый синтаксический
элемент, то это придётся делать трижды. Синтаксические коллекции упрощают
работу с такими определениями, позволяя использовать одну коллекцию для
нескольких синтаксических групп.

Чтобы определить коллекцию для двух синтаксических элементов, которые включены
в состав указанных групп, используйте такую команду
>
	:syntax cluster xState contains=xNumber,xIdent
<
Коллекции можно использовать внутри других синтаксических элементов как любую
другую синтаксическую группу. Наименования коллекция в этом случае указываются
с приставкой '@'. Иными словами, показанные выше три группы можно определить
с использованием коллекций так:
>
	:syntax match xFor /^for.*/ contains=@xState
	:syntax match xIf /^if.*/ contains=@xState
	:syntax match xWhile /^while.*/ contains=@xState
<
Чтобы добавить новые группы в коллекцию, используйте аргумент «add»
>
	:syntax cluster xState add=xString
<
Чтобы удалить синтаксические группы из коллекции, применяется аргумент «remove»
>
	:syntax cluster xState remove=xNumber
<
==============================================================================
*44.9*	Включение других файлов с правилами синтаксиса

Язык программирования Си++ является надмножеством языка Си. Поскольку нет
смысла дважды описывать одни и те же элементы для языков Си и Си++, можно
подключать файл с правилами описания синтаксиса языка Си в файл с правилами
синтаксиса Си++. Для этого воспользуемся командой
>
	:runtime! syntax/c.vim
<
По команде ":runtime!" будет выполнен поиск всех файлов «syntax/c.vim» по тем
маршрутам, которые указаны в параметре 'runtimepath'. Таким образом, части
синтаксиса языка Си++ на языке Си определяются так же, как и для файлов языка
Си. Если вы замените файл синтаксиса «c.vim» или напишите дополнительный файл,
то все эти изменения также будут работать в файле синтаксических правил для
языка Си++.

После загрузки синтаксических правил для языка Си, можно определить элементы,
которые относятся только к языку Си++. Например, добавить ключевые слова,
которых нет в языке Си
>
	:syntax keyword cppStatement	new delete this friend using
<
Все команды будут работать точно так же, как и в любом другом файле с
правилами синтаксиса.

Хорошим примером будет язык Perl. С точки зрения синтаксиса, он состоит из
двух различных частей: документации в формате POD и самой программы на языке
Perl. Раздел POD начинается с команды «=head» и заканчивается командой «=cut».

Было бы разумно определить синтаксис для POD в одном файле и затем
использовать эти правила уже в другом файле, где определяется синтаксис для
самого языка Perl. По команде ":syntax include" будет выполнено подключение
элементов, определённых в другом файле, в виде синтаксической коллекции. Для
языка Perl мы используем следующие команды:
>
	:syntax include @Pod <sfile>:p:h/pod.vim
	:syntax region perlPOD start=/^=head/ end=/^=cut/ contains=@Pod
<
Если в файле языка Perl встречается команда «=head», то начинает действовать
синтаксическая область «perlPOD». Эта область содержит коллекцию «@Pod».
Таким образом, все элементы, определённые на верхнем уровне правил синтаксиса
в файле «pod.vim» будут применяться для этой области. Когда в тесте встретится
команда «=cut», то эта область заканчивается и мы возвращаемся к элементам
синтаксиса, определённым в файле Perl.

Реализация команды ":syntax include" достаточно интеллектуальна, чтобы
игнорировать встречающуюся во внешнем файле команду ":syntax clear", а
аргументы вроде «contains=ALL» будут включать только элементы, определённые во
включаемом внешнем файле, но не в файле, который включает этот внешний файл.

Конструкция "<sfile>:p:h/" использует наименование текущего файла (<sfile>),
извлекая полный маршрут (:p) и затем отсекая начальную часть (:h), чтобы
получить наименование каталога, в котором расположен файл. В результате
подключается файл «pod.vim» из того же каталога, что и текущий файл.

==============================================================================
*44.10*	Синхронизация

Вот как же легко компиляторам — считывают и анализируют текст файла от самого
начала до самого конца. А для редактора Vim не всё так просто и легко. Ему
приходится считывать текст чуть ли не с середины строки, то есть там, где
началось редактирование файла. Как же в таком случае он решает задачу разбора
синтаксиса?

Весь секрет, как оказывается, в использовании команды ":syntax sync". Именно
с помощью этой команды можно получить подсказку, чтоб определить какой текст
сейчас редактируется.
Например, по следующей команде будет выполнен ретроспективный поиск начала или
конца комментария в стиле языка Си, и от этого места начнётся дальнейшая
подсветка синтаксиса
>
	:syntax sync ccomment
<
Этот процесс можно более точно настроить с помощью дополнительный аргументов.
Так, через аргумент «minlines» указывается минимальное количество строк,
которое необходимо просматривать при ретроспективном поиске, а через аргумент
«maxlines» — максимальное общее количество строк.

По следующей команде редактором Vim будут просмотрены как минимум 10 строк в
обратном направлении от верхней строки экрана
>
	:syntax sync ccomment minlines=10 maxlines=500
<
Если в этом количестве строк не содержится достаточно ясного определения
текущего синтаксического элемента, то просмотр будет продолжаться такими же
порциями всё ближе и ближе к началу файла, пока не станет понятно в какой
части кода находится. При этом пространство поиска ограничивается пятьюстами
строками. Большая величина аргумента «maxlines» замедляет разбор синтаксиса,
а слишком маленькая величина может привести к потере синхронизации подсветки
синтаксиса.

Чтобы синхронизация выполнялась быстрее, можно указать какие элементы
разрешается пропустить при анализе текста. Все сопоставления и области,
которые используются только при непосредственном отображении на экране лучше
снабжать аргументом «display».

По умолчанию комментарии подсвечиваются как часть синтаксической группы
«Comment». Если необходимо подсвечивать их как-то иначе, то можно определить
другую синтаксическую группу
>
	:syntax sync ccomment xAltComment
<
Если язык программирования имеет собственный стиль комментариев, отличный от
стиля комментариев языка Си, то можно попытаться использовать другой метод
синхронизации. Самое простое, это указать редактору Vim вернуться назад на
некоторое количество строк и выполнить анализ синтаксиса начиная с того места.
Следующая команда предписывает редактору Vim выполнять анализ синтаксиса в
предыдущих сто пятидесяти строках от текущего положения каретки в тексте
>
	:syntax sync minlines=150
<
Большая величина аргумента «minlines» приводит к замедлению работы редактора
Vim, особенно при прокрутке файла назад.

Наконец, можно указать синтаксическую группу, которую следует искать для
синхронизации, при помощи такой команды
 >
	:syntax sync match {имя-группы-синхронизации}
		\ grouphere {имя-группы} {шаблон}
<
В этой команде редактору Vim указывается, что сразу после данного {шаблона}
начинается синтаксическая группа {название-группы}. Для присвоения названия
группы синхронизации, используется аргумент {название-группы-синхронизации}.
Например, в языке командных файлов оболочки sh условные выражение начинается
со слова «if» и заканчивается словом «fi»:

    if [ --f file.txt ] ; then ~
	    echo "File exists" ~
    fi ~

Чтобы определить аргумент «grouphere» для этого синтаксического элемента,
используйте следующую команду:
>
	:syntax sync match shIfSync grouphere shIf "\<if\>"
<
Аргумент «groupthere» указывает редактору Vim на шаблон, которым заканчивается
синтаксическая группа.
Например, конец синтаксической группы if-fi определяется так:
>
	:syntax sync match shIfSync groupthere NONE "\<fi\>"
<
В этом примере слово «NONE» указывает, что в этом месте перестаёт действовать
какая-либо синтаксическая область. В частности, эта позиция текста не
принадлежит блоку условного выражения.

Также можно определять синтаксические сопоставления и области без аргументов
«grouphere» и «groupthere». Такие группы пропускаются во время синхронизации.
Например, по следующей команде будет пропускаться области внутри скобок {},
даже если они соответствуют другим командам синхронизации:
>
	:syntax sync match xSpecial /{.*}/
<
Подробнее о синхронизации читайте в справочнике — |:syn-sync|.

==============================================================================
*44.11*	Подключение файла синтаксиса к редактору Vim

Когда файл с правилами синтаксиса готов к использованию, поместите его в
каталог «syntax» в одном из каталогов, указанных в параметре 'runtimepath'.
В UNIX-подобных системах это может быть, например, каталог «~/.vim/syntax».

Наименование файла с правилами синтаксиса должно соответствовать типу файла с
добавлением расширения «.vim». Для нашего языка x полное название файла будет

    ~/.vim/syntax/x.vim ~

Кроме того, необходимо позаботиться о том, чтобы тип файла правильно
распознавался в редакторе Vim. См. параграф |43.2|.

Если созданный файл с правилами разбора синтаксиса отлично работает, то
возможно стоит поделиться им с другими пользователями редактора Vim. Прежде
всего прочитайте следующий параграф, чтобы убедиться, что файл будет также
хорошо работать и у других пользователей. Затем отправьте его по почте
координатору проекта Vim — <maintainer@vim.org>. Также опишите как должен
распознаваться тип файла. Если всё будет работать так, как полагается, то этот
файл может быть включён в состав поставки следующей версии редактора Vim!


ДОБАВЛЕНИЯ К СУЩЕСТВУЮЩЕМУ ФАЙЛУ СИНТАКСИСА

В этой главе предполагалось, что мы создаём совершенно новый файл синтаксиса.
Если файл с правилами синтаксиса для языка уже существует и в целом неплохо
работает, но хотелось бы его немного дополнить, то в этом случае можно
добавлять элементы синтаксиса в отдельном файле. Это позволяет избежать
внесения изменений в файле, который поставляется вместе с редактором Vim —
в таком случае изменения могут быть потеряны при установке новой версии Vim.

Можете создать собственный файл с командами ":syntax", возможно пользуясь
группами из уже существующего файла. Например, чтобы добавить новые типы
переменных в синтаксис языка Си
>
	:syntax keyword cType off_t uint
<
Сохраните файл с тем же наименованием, что и оригинальный файл синтаксиса.
В данном случае это будет «c.vim». Теперь поместите его в каталог, который
находится ближе к концу списка каталогов в параметре 'runtimepath'. Это
позволяет загружать вновь созданный файл после стандартного файла синтаксиса.
В UNIX-подобных системах это может быть, например,

    ~/.vim/after/syntax/c.vim ~

==============================================================================
*44.12*	Общий формат файла синтаксиса

Было бы здорово, если бы пользователи редактора Vim могли бы обмениваться
файлами с правилами синтаксиса. Для этого требуется выполнение ряда нескольких
рекомендаций при создании файла синтаксических правил.

Начните файл с заголовка, который поясняет для чего создан данный файл, кто
его автор и когда он был в последний раз изменён. Не стоит включать подробную
информацию об истории изменений, её всё равно мало кто читает. Пример:
 >
	" Vim syntax file
	" Language:	C
	" Maintainer:	Bram Moolenaar <Bram@vim.org>
	" Last Change:	2001 Jun 18
	" Remark:	Included by the C++ syntax.
<
Используйте тот же формат, что и другие файлы синтаксиса. Можете сэкономить
время, если воспользуетесь существующим файлом синтаксиса в качестве образца.

Выберите хорошее описательное наименование для вашего файла синтаксиса.
Используйте строчные буквы и цифра в названии. Не стоит делать наименование
слишком длинным: оно будет использоваться во многих местах — название файла
синтаксиса "name.vim", 'filetype', b:current_syntax и как начало каждой
синтаксической группы (nameType, nameStatement, nameString и т. п.)

В самом начале файла выполните проверку наличия переменной «b:current_syntax».
Если она существует, то это значит, что был загружен другой файл синтаксиса
из каталога, указанного где-то раннее в параметре 'runtimepath'.
>
	if exists("b:current_syntax")
	  finish
	endif

В конце файла установите переменой «b:current_syntax» название синтаксиса в
качестве значения.
Не забудьте, что это будет также сделано подключаемыми файлами, так что если
подключаете два файла, то придётся сбросить переменную «b:current_syntax».

Не указывайте в файле ничего, что является пользовательскими настройками.
Не устанавливайте значения параметров 'tabstop', 'expandtab' и т. д.
Всё это имеет отношение к модулям типа файлов, а не к файлам синтаксиса.

Не указывайте в файле клавиатурные команды или сокращения. Изменяйте значение
параметра 'iskeyword' только в том случае, когда это необходимо для
распознавания ключевых слов.

Чтобы пользователи могли сами выбирать предпочитаемые цвета, делайте
различающиеся названия групп для каждого вида подсвечиваемых элементов. Затем
свяжите каждую из них с одной из стандартных групп подсветки. Это позволит
использовать их в любой цветовой схемах. Избегайте назначения конкретных
цветов, это может неудачно выглядеть для некоторых цветовых гамм. И не
забывайте, что люди пользуются различными цветами для фона, а у некоторых на
терминале доступно только восемь цветов.

Для привязки к стандартным группам подсветки, используйте команду "hi def link",
чтобы пользователи могли выбрать другую подсветку перед загрузкой созданного
файла синтаксических правил. Примеры:
>
	  hi def link nameString	String
	  hi def link nameNumber	Number
	  hi def link nameCommand	Statement

	  ... и т. д. ...
<
Для элементов, которые не используются при синхронизации, добавьте аргумент
«display», чтобы ускорить прокрутку назад и обновление экрана с помощью клавиш
CTRL-L.

==============================================================================

Следующая глава «Региональные настройки», |usr_45.txt|.
Об авторских правах на документацию см. |manual-copyright|.

© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

 vim:tw=78:ts=8:noet:ft=help:norl:
