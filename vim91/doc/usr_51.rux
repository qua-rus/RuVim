*usr_51.txt*	для Vim version 9.1		   редакция от 04 апр 2024 г.

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

		   Создание подключаемых модулей редактора


Для редактора Vim подключаемые модули могут использоваться для установки
настроек у определённых типов файлов, разбора и подсветки синтаксиса языков
программирования в текстовых файлах и множества другого функционала
облегчающего и ускоряющего работу в редакторе. В этой главе рассказывается и
приводятся примеры по созданию наиболее распространённых видов подключаемых
модулей для редактора Vim.

|51.1|	Создание общих модулей
|51.2|	Создание модулей для типов файлов
|51.3|	Создание модулей для компиляторов
|51.4|	Распространение модулей для редактора Vim

  Следующая глава «Создание крупных подключаемых модулей», |usr_52.txt|.
 Предыдущая глава «Расширенные возможности командных файлов Vim», |usr_50.txt|.
       Содержание, |usr_toc.txt|.
==============================================================================
*51.1*	Создание общих модулей				*write-plugin*

В редакторе Vim предоставляется возможность написать командный файл (сценарий)
Vim с тем, чтобы им могли пользоваться многие пользователи. Такой командный
файл называется модулем. Пользователи редактора Vim могут поместить такой
модуль в свой каталог «plugin» и использовать его возможности. См. |add-plugin|.

Вообще, существует два вида модулей:

	 общие модули — используются для всех типов файлов;
    модули типа файла — используются только для определённых типов файла.

В этом параграфе мы рассмотрим модули первого типа, т. е. общие модули.
Большинство из изложенного материала в этом параграфе также применимо и к
написанию модулей типов файлов. Особенности модулей типа файла рассматриваются
в следующем параграфе, см. |write-filetype-plugin|.

Мы буде использовать новый синтаксис Vim9 встроенного языка программирования,
это рекомендованный способ для создания новых модулей.
Создания командного файла начинается с команды `vim9script`.

НАИМЕНОВАНИЕ

Прежде всего следует выбрать название для создаваемого модуля. Наименование
должно ясно указывать на функциональность модуля и, кроме того, маловероятно,
что кто-то напишет модуль с таким-же наименованием, но выполняющий совершенно
иные действия.

В качестве примера мы напишем командный файл, функционал которого позволяет
исправлять некоторые опечатки. Назовём этот модуль «typecorrect.vim».

Чтобы модуль работал для всех пользователей, необходимо придерживаться ряда
рекомендаций. Мы объясним здесь всё шаг за шагом, а полный текст модуля
приведём в конце раздела.


ТЕЛО МОДУЛЯ

Начнём с тела модуля, т. е. строк, которые выполняют непосредственно работу в
нашем командном файле:
>
 12	iabbrev teh the
 13	iabbrev otehr other
 14	iabbrev wnat want
 15	iabbrev synchronisation
 16		\ synchronization
<
Конечно, список может быть и более длинным.

Номера строк здесь добавлены только для объяснения некоторых особенностей. Не
помещайте их в командный файл!


ПЕРВАЯ СТРОКА
>
  1	vim9script noclear
<
Необходимо указать команду `vim9script` как самую первую команду. Хорошим
тоном считается размещать её в самой верхней строке командного файла.

Командный файл, который мы создаём будет иметь команду ":finish" для
завершения работы, если обнаружится повторная загрузка этого самого командного
файла. Чтобы предотвратить потерю элементов, определённых в этом скрипте,
используется аргумент «noclear». Более подробно об этом здесь — |vim9-reload|.


ЗАГОЛОВОК

Скорее всего по мере работы будут вноситься исправления в модуль и вскоре у
нас появится несколько версий. При распространении этого файла люди захотят
узнать, кто написал этот замечательный модуль и кому они могут отправить свои
комментарии. Поэтому, вверху модуля поместим заголовок
>
  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>
<
Стоит, наверное, сказать о лицензировании и авторском праве в мире победившего
капитализма.
Поскольку модули могут быть крайне полезными, а ограничивать их
распространение вряд ли имеет смысл, подумайте о том, чтобы либо сделать их
общественным достоянием, либо распространять по |license| Vim.
Краткого упоминания в самом начале файла модуля вполне достаточно. Например,
>
  5	# License:	This file is placed in the public domain.
<

ОТКАЗ ОТ ЗАГРУЗКИ

Возможно, пользователь не всегда захочет загружать данный модуль одновременно
с запуском редактора Vim. Или системный администратор переместить его в общий
для всех пользователей каталог, а какой-либо пользователь захочет использовать
вместо него собственный модуль. В любом случае, у пользователя должна быть
возможность отказа от загрузки данного модуля. И это возможно решить, указав
следующим строки в начале модуля
>
  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1
<
Этот простой код позволяет избежать ошибок с переопределении функций и
повторным выполнения автокоманд при многократной загрузке модуля.

Наименование переменной настоятельно рекомендуется начинать со слов
«g:loadeede_» и после этого уже буквальное наименование файла модуля.
Приставка «g:», как мы уже говорили, помещает переменную в глобальную область
видимости, что позволяет любому пользователю проконтролировать её значение и
доступность. В противном случае такая переменная без приставки «g:» считалась
бы локальной для командного файла.

Применение команды ":finish" сообщает редактору Vim остановить обработку
остальной части командного файла (модуля). Это является своего рода
оптимизацией по сравнению с использованием условных операторов if-endif, так
как редактору Vim пришлось бы обрабатывать весь файл, чтобы найти
соответствующую команду ":endif".


КЛАВИАТУРНЫЕ КОМАНДЫ

Теперь сделаем наш модуль немного более интерактивным — добавим клавиатурную
команду, которая добавляет исправление найденной опечатке в словах,
расположенных под кареткой.
Мы могли бы просто назначить такую клавиатурную команду для первой
понравившейся нам клавиши, но, во‐первых, пользователь может уже назначить на
эту клавишу свою собственную клавиатурную команду. Чтобы пользователь мог сам
определить клавишу для такой клавиатурной команды, добавим спецсимвол <Leader>
>
 20	  map <unique> <Leader>a  <Plug>TypecorrectAdd;
<
запись «<Plug>TypecorrectAdd;» будет выполнять требуемую нам работу, подробнее
об этом читайте ниже.

Так как пользователь может установить значение для переменной «g:mapleader» в
некоторую последовательность клавиш, которые будут использованы как начало
клавиатурной команды модуля. Например, если пользователь введёт
>
	g:mapleader = "_"
<
то клавиатурная команда будет определена как «_a«. В противном случае будет
использовано значение по умолчанию — обратная наклонная черта, т.е. будет
определена клавиатурная команда для «\a».

Обратите внимание, что используется аргумент <unique>, а значит при попытке
переопределения существующей клавиатурной команды, будет сообщение об ошибке.
|:map-<unique>|

Однако, не стоит забывать, что пользователь может определить собственную
последовательность клавиш! И это можно реализовать при помощи такого механизма
>
 19	if !hasmapto('<Plug>TypecorrectAdd;')
 20	  map <unique> <Leader>a  <Plug>TypecorrectAdd;
 21	endif
<
В данном коде мы проверяем, существует ли клавиатурная привязка для значения
«<Plug>TypecorrectAdd;» и определяем команду для «<Leader>a» только в том
случае, если она не существует. А значит, пользователь может добавить в файл
«vimrc»
>
	map ,c  <Plug>TypecorrectAdd;
<
чтобы последовательность клавиш для команды вместо «_a» или «\a» была «,c».


ФРАГМЕНТЫ

Если командный файл в процессе работы над ним становится достаточно объёмным,
то работу над ним можно разбить на отдельные фрагменты. Для этих целей можно
использовать функции или клавиатурные команды. Однако, такие функции и
клавиатурные команды не должны входить в конфликт с другими существующими
модулями. Например, возможно определить функцию Add(), которая также может
быть определена и в другом командном файле. Чтобы не было пересечений,
определим функцию как локальную по отношению к данному командному файлу.
Благодаря новой версии |Vim9| для языка программирования VimL, такое происходит
само собой. Но в предыдущих версиях это достигается при помощи приставки «s:».

Итак, определим функцию, которая добавляет новую опечатку
>
 28	def Add(from: string, correct: bool)
 29	  var to = input($"type the correction for {from}: ")
 30	  exe $":iabbrev {from} {to}"
 ...
 34	enddef
<
Теперь мы можем вызывать из данного сценария функцию Add(). Если вдруг другой
сценарий также определяет функцию Add(), то она будет локальной по отношению к
тому командному файлу, из которого вызывается. Кроме того, может быть
определена глобальная функция g:Add(), которая уже будет отдельной функцией.

В клавиатурных командах можно использовать приставку <SID>. Запись <SID> — это
автоматически генерируемый идентификатор (ИД), который уникален для данного
командного файла и позволяет его идентифицировать. В нашем модуле мы можем
использовать приставку <SID> так:
 >
 22	noremap <unique> <script> <Plug>TypecorrectAdd;  <SID>Add
 ...
 26	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>
<
Теперь, когда пользователь вводит «\a», то выполняются следующие действия:
>
	\a  ->  <Plug>TypecorrectAdd;  ->  <SID>Add  ->  :call <SID>Add(...)
<
В случае, если другой командный файл использует клавиатурную команду для
<SID>Add, то это будет уже иная клавиатурная команда, с другим идентификатором
сценария.

Обратите внимание, что здесь используется <SID>Add() вместо Add(). Это связано
с тем, что клавиатурная команда вводится пользователем, вне файла контекста
сценария. Запись <SID> преобразуется в идентификатор сценария, поэтому
редактор Vim распознаёт в каком командном файле надо искать функцию Add().

Хотя всё это и выглядит немного сложным, такой механизм требуется, чтобы
модуль корректно работал с другими модулями. Основное правило состоит в том,
чтобы использовать <SID>Add() в клавиатурных командах, и Add() в остальных
местах (таких как сам сценарий, автокоманды, командах пользователя).

Мы также можем добавить пункт меню для выполнения тех же функций
>
 24	noremenu <script> Plugin.Add\ Correction      <SID>Add
<
Для относящихся к модулям меню рекомендуется использовать пункты «Plugin».
В данном случае используется только один пункт меню. При использовании
нескольких пунктов, рекомендуется создать подменю. Например, подменю
«Модули.CVS» можно использовать для модуля, который содержит операций для CVS
«Модули.CVS.поместить», «Модули.CVS.забрать» и т. п.

Обратите внимание, что в строке 26 используется команда ":noremap" во
избежание конфликтов с другими клавиатурными командами. Например, кто-то может
пожелать переопределить команду для ":call". В строке 22 также используется
":noremap", но при этом мы предоставляем переопределение команды для
«<SID>Add». Вот почему в этом случае мы указали аргумент «<script>». Это
позволяет использовать только клавиатурные команды, которые определены как
локальные для данного командного файла. |:map-<script>| Аналогичная операция
выполняется и в строке 24 для команды ":noremenu". |:menu-<script>|


<SID> и <Plug>						*using-<Plug>*

Запись <SID>, как и запись <Plug> используются для того, чтобы избежать
конфликта вводимых символов команд с другими командами, которые используются
только в других клавиатурных командах. Обратите внимание на различия между
записями <SID> и <Plug>

<Plug>	распознаётся за пределами командного файла. Это запись используется
	для команд, для которым пользователь может присвоить собственную
	последовательность символов. Запись <Plug> образует специальный код,
	который нельзя воспроизвести нажатием клавиш. Чтобы свести возможность
	ситуации, когда другие модули используют ту же последовательность
	символов, применяйте такую последовательность записей — <Plug>
	название_сценария название_клавиатурной-команда. В нашем примере
	название модуля «Typecorrect», а название команды «Add». Мы также
	добавили символ точка с запятой как ограничитель. В результате
	получается «<Plug>TypecorrectAdd;». Чтобы выделить, где начинается
	название клавиатурной команды, мы используем в качестве первых
	символов прописные буквы.

<SID>	это уникальный идентификатор сценария, его ИД. Внутри самого редактора
	Vim запись <SID> преобразуется в нечто похожее на "<SNR>123_", где
	«123» может быть любой последовательностью чисел. Таким образом,
	функция "<SID>Add()" может иметь в одном сценарии название
	"<SNR>11_Add()" и название "<SNR>22_Add()" в другом сценарии. Это
	можно заметить, если посмотрите перечня определённых функций выводимый
	по команде ":function". Преобразование <SID> в клавиатурных командах
	происходит точно так же, поэтому возможно вызывать из клавиатурной
	команды локальную по отношению к командному файлу функцию.


ПОЛЬЗОВАТЕЛЬСКИЕ КОМАНДЫ

Теперь добавим команду для добавления исправления:
>
 36	if !exists(":Correct")
 37	  command -nargs=1  Correct  :call Add(<q-args>, false)
 38	endif
<
Эти строки кода формируют пользовательскую команду для исправления опечаток.
Пользовательская команда будет сформирована только в том случае, если ранее
не объявлялась пользовательская команда с таким наименованием в других модулях,
командных файлах, функциях. При объявлении пользовательских команд с
совпадающими наименованиями будет выдано сообщение об ошибке. Также не
рекомендуется использовать команду ":command" с модификатором '!' для
принудительного переопределения ранее объявленных команд с такими же
наименованиями. Это, как минимум, может расстроить пользователя, т. к.
выполняемые по команде действия не будут соответствовать его ожиданиям.
Подробности об объявлении пользовательских команд смотрите здесь —  |:command|.
Если всё же возникают ошибки, то для уточнения причин воспользуйтесь командой
>
	verbose command Correct
<

ПЕРЕМЕННЫЕ В СЦЕНАРИИ

Переменная, которая имеет приставку «s:» является переменной только командного
файла (script, сценарий), и, соответственно, область её видимости ограничена
этим командным файлом. Это позволяет использовать переменные с совпадающими
наименованиями в различных командных файла. Объявленные переменные остаются
на протяжении всего сеанса работы редактора Vim. Переменные будут использованы
повторно при вызове того же самого командного файла. Детали читайте в — |s:var|.

Особенностью новой версии |Vim9| языка программирования является то, что
переменные по умолчанию являются локальными для командного файла. Добавление
приставки «s:» в этом случае не имеет смысла, хотя и возможно по желанию.
Функции в командном файле могут использовать такие переменные без приставки.
Однако такие переменные командного файла должны быть объявлены перед вызовом
в функции.

Эти локальные переменные командного файла могут быть свободно использованы в
функциях, автокомандах и пользовательских командах, определённых в сценарии.
Таким образом, подобные переменные являются идеальным способом обмена
информации без её выхода за пределы командного файла. В нашем примере можно
добавить несколько строк, которые будут подсчитывать число исправлений:
>
 17	var count = 4
 ...
 28	def Add(from: string, correct: bool)
 ...
 32	  count += 1
 33	  echo "you now have " .. count .. " corrections"
 34	enddef
<
В самом командном файле переменная «count» объявляется и инициализируется
значением, равным 4. Затем, при вызове функции Add() мы увеличиваем значение
«count» на единицу. Не имеет значения, откуда вызвана функция Add() — будут
использованы локальные по отношению к командному файлу переменные, поскольку
сама функция определена внутри этого командного файла.


РЕЗУЛЬТАТ

Вот полный текст нашего модуля:
>
  1	vim9script noclear
  2	# Vim global plugin for correcting typing mistakes
  3	# Last Change:	2021 Dec 30
  4	# Maintainer:	Bram Moolenaar <Bram@vim.org>
  5	# License:	This file is placed in the public domain.
  6
  7	if exists("g:loaded_typecorrect")
  8	  finish
  9	endif
 10	g:loaded_typecorrect = 1
 11
 12	iabbrev teh the
 13	iabbrev otehr other
 14	iabbrev wnat want
 15	iabbrev synchronisation
 16		\ synchronization
 17	var count = 4
 18
 19	if !hasmapto('<Plug>TypecorrectAdd;')
 20	  map <unique> <Leader>a  <Plug>TypecorrectAdd;
 21	endif
 22	noremap <unique> <script> <Plug>TypecorrectAdd;  <SID>Add
 23
 24	noremenu <script> Plugin.Add\ Correction      <SID>Add
 25
 26	noremap <SID>Add  :call <SID>Add(expand("<cword>"), true)<CR>
 27
 28	def Add(from: string, correct: bool)
 29	  var to = input("type the correction for " .. from .. ": ")
 30	  exe ":iabbrev " .. from .. " " .. to
 31	  if correct | exe "normal viws\<C-R>\" \b\e" | endif
 32	  count += 1
 33	  echo "you now have " .. count .. " corrections"
 34	enddef
 35
 36	if !exists(":Correct")
 37	  command -nargs=1  Correct  call Add(<q-args>, false)
 38	endif
<
Код в строке номер 31 мы ещё не разбирали. Здесь происходит присвоение нового
исправления к слову, находящемся под кареткой. Для применения нового
сокращения используется команда |:normal|. Обратите внимание, что несмотря на
то, что вызывается клавиатурная команда, определённая с помощью команды
":noremap", в этом случае выполняется подстановка для команд и сокращений.


ДОКУМЕНТАЦИЯ						*write-local-help*

Для модуля всегда неплохо написать краткий файл справки, особенно в тех
случаях, когда действие модуля может изменяться пользователем. Подробнее о
том, как установить файл справки, читайте в |add-local-help|.

Вот пример справки для нашего модуля, который мы назвали «typecorrect.txt»:
>
  1	*typecorrect.txt*	Plugin for correcting typing mistakes
  2
  3	If you make typing mistakes, this plugin will have them corrected
  4	automatically.
  5
  6	There are currently only a few corrections.  Add your own if you like.
  7
  8	Mappings:
  9	<Leader>a   or   <Plug>TypecorrAdd;
 10		Add a correction for the word under the cursor.
 11
 12	Commands:
 13	:Correct {word}
 14		Add a correction for {word}.
 15
 16							*typecorrect-settings*
 17	This plugin doesn't have any settings.
<
Первая строка в файле документации — обязательная строка, для которой
необходимо соблюсти определённый формат.
Именно содержимое этой строки будет показано в разделе
«ЛОКАЛЬНАЯ ДОКУМЕНТАЦИЯ» в файла «help.txt» (см. |local-additions|).
Первый символ «*» (звёздочка) должен находиться в самом первом столбце первой
строки. После добавления файла справки выполните команду ":help" и убедитесь,
что записи красиво выровнены друг против друга.

Внутри файла справки вы можете добавлять собственные индексы межу символам
«*» и «*». Однако, будьте внимательны, чтобы не было совпадений с уже раннее
определёнными индексами. Лучше всего использовать в качестве приставки к
индексу наименование модуля, как в нашем примере: «typecorrect-settings».

Рекомендуется также использовать |bars| (вертикальные линии) для указания
ссылок на другие части справочной системы. Это позволяет пользователю легко
находить необходимую ему информацию.


РЕЗЮМЕ							*plugin-special*

Перечислим специальные элементы, которые используются в модулях:

var name		Переменная, локальная по отношению к сценарию

<SID>			Идентификатор сценария, используется для клавиатурных
			команд и функций, локальных по отношению к сценарию.

hasmapto()		Функция, проверяющая наличие клавиатурной команды
			для данного значения, которое предлагается сценарием.

<Leader>		Значение переменной «mapleader» для определения начала
			клавиатурной команды для данного модуля.

map <unique>		Будет отображено предупреждение, если клавиатурная
			команда уже существует.

noremap <script>	Использовать только локальные по отношению к данному
			сценарию клавиатурные команды, а не глобальные

exists(":Cmd")		Проверка существования пользовательской команды.

==============================================================================
*51.2*	Создание модуля типа файла	*write-filetype-plugin*  *ftplugin*

Модуль типа файла похож на модуль общего назначения, с тем исключением, что
в этом модуле выполняется установка параметров и определяются клавиатурные
команды только для текущего буфера. Подробнее об использовании таких модулей
см. в |add-filetype-plugin|.

Прочитайте внимательно параграф об общих модулях, |51.1|. Всё, что говорилось
в данном параграфе, относится также и к модулям типа файла. А специфические
особенности модулей типа файла будет изложен в этом параграфе. Самое главное,
что необходимо усвоить, это то, что модуль типа файла должен применяться
только к текущему буферу.


ОТКЛЮЧЕНИЕ МОДУЛЯ

Если применение модуля типа файла возможно неограниченным кругом лиц, то
необходимо предусмотреть возможность отключения этого модуля. Поэтому, в
начале модуля следует поместить такой код:
>
	# Only do this when not done yet for this buffer
	if exists("b:did_ftplugin")
	  finish
	endif
	b:did_ftplugin = 1
<
Код также позволяет предотвратить повторное применение этого же модуля для
данного буфера, что может произойти при вызове команды ":edit" без аргументов.

Исходя из приведённого выше кода, пользователи могут отключить загрузку модуля
типа файла, просто создав свой модуль содержащий следующие строки:
>
	vim9script
	b:did_ftplugin = 1
<
Однако, это требует, чтобы каталог с пользовательскими модулями типов файла
был указан до каталога $VIMRUNTIME в списке значений параметра 'runtimepath'!

Если при использовании основного модуль для данного типа файлов необходимо
изменить некоторые настройки, то требуется указать эти настройки в другом
командном файле
>
	setlocal textwidth=70
<
И теперь поместите данный командный файл в каталоге «after», чтобы он мог быть
обработан редактором после того, как будет загружен стандартный модуль типа
файла, скажем, «vim.vim», см. |after-directory|. В UNIX-подобных системах это
будет «~/.vim/after/ftplugin/vim.vim». Обратите внимание, что в стандартном
модуле будет установлена переменная «b:did_ftplugin», так что при повторной
загрузке ничего не произойдёт.


ПАРАМЕТРЫ

Чтобы быть уверенным в том, что модуль типа файла затрагивает только текущий
буфер, используйте для установки значения параметров команду
>
	:setlocal
<
и применяйте только локальные по отношению к данному буферу параметры (не
ленитесь заглядывать в справочник). При указании команды |:setlocal| для
глобальных параметров или параметров, которые являются локальными по отношению
к окну, значение будет изменяться также и для других буферов, а модуль типа
файла не должен этого делать.

При использовании параметров, значение которых представляют собой список
нескольких элементов или флагов, старайтесь использования операции "+=" и "-="
для изменения конкретного флага или элемента и сохранения других существующих
значений. Имейте в виду, что пользователь может уже изменить значение того или
иного параметра. Часто может потребоваться сброс значения параметра к значению,
используемому по умолчанию, и установке дополнительных значений параметра.
Пример,
>
	:setlocal formatoptions& formatoptions+=ro
<

КЛАВИАТУРНЫЕ КОМАНДЫ

Чтобы быть уверенным в том, что клавиатурная команда будут работать только в
текущем буфере, используйте команду
>
	map <buffer>
<
Этот аргумент необходимо комбинировать с ранее приведённым способом назначения
клавиатурных команд.
Пример определения функциональности в модуле типа файла:
>
	if !hasmapto('<Plug>JavaImport;')
	  map <buffer> <unique> <LocalLeader>i <Plug>JavaImport;
	endif
	noremap <buffer> <unique> <Plug>JavaImport; oimport ""<Left><Esc>
<
Функция |hasmapto()| используется для проверки существования клавиатурной
команды для значения <Plug>JavaImport;. Если команды не существует, то
используется клавиатурная команда по умолчанию. Эта команда начинается со
спецсимвола |<LocalLeader>|, который позволяет пользователю выбрать клавиши, с
которых должны начинаться клавиатурная команда для модулей данного типа файла.
Значением по умолчанию спецсимвола является символ обратной наклонной черты.
Аргумент «<unique>» используется для вывода сообщения об ошибке в том случае,
если клавиатурная команда уже существует, или конфликтует с другой
существующей клавиатурной командой.
Команда |:noremap| используется во избежание конфликта с другими клавиатурными
командами, определёнными пользователем. Допускается использовать команду
":noremap <script>" для того, чтобы позволить переопределение клавиатурных
команд, начинающихся с записи <SID> в данном командном файле.

У пользователя должна быть возможность отключения клавиатурных команд,
определённых модулем типа файла, без необходимости отключения всех
клавиатурных команд.
Приведём пример того, как это можно сделать в модуле для почтового файла:
>
	# Add mappings, unless the user didn't want this.
	if !exists("g:no_plugin_maps") && !exists("g:no_mail_maps")
	  # Quote text by inserting "> "
	  if !hasmapto('<Plug>MailQuote;')
	    vmap <buffer> <LocalLeader>q <Plug>MailQuote;
	    nmap <buffer> <LocalLeader>q <Plug>MailQuote;
	  endif
	  vnoremap <buffer> <Plug>MailQuote; :s/^/> /<CR>
	  nnoremap <buffer> <Plug>MailQuote; :.,$s/^/> /<CR>
	endif
<
В этом программном коде использованы две глобальные переменные:
«no_plugin_maps» — отключает клавиатурные команды для всех модулей типа файла;
«no_mail_maps» — отключает клавиатурные команды для данного модуля типа файла.


ПОЛЬЗОВАТЕЛЬСКИЕ КОМАНДЫ

Чтобы добавить пользовательские команды для определённого типа файла,
ограниченные применением только в данном буфере, используйте аргумент
«-buffer» с командой |:command|. Пример,
>
	command -buffer  Make  make %:r.s
<

ПЕРЕМЕННЫЕ

Модуль типа файла считывается для каждого буфера с данным типом файла.
Локальные переменные командного файла используются всеми модулями данного типа
совместно. Если требуется использовать какую-либо переменную строго в пределах
данного буфера, используйте переменные, локальные только для буфера — |b:var|.


ФУНКЦИИ

Определение функции требуется выполнять только один раз. Поскольку модуль типа
файла считывается всякий раз, когда открывается файл с данным типом файла, то
следует пользоваться следующей конструкцией:
>
	if !exists("*Func")
	  def Func(arg)
	    ...
	  enddef
	endif
<
Не забудьте использовать аргумент «noclear» с командой `vim9script`, чтобы
избежать удаления функции при повторном запуске командного файла.


ОТМЕНА						*undo_indent*  *undo_ftplugin*

Если пользователь вводит команду вроде ":setfiletype xyz", то эффект
предыдущего определения типа должен быть отменён. Для этого можно установить
значение переменной «b:undo_ftplugin» равным списку команд, которые должны
быть выполнены, чтобы отменить действие модуля типа файла. Например:
>
	b:undo_ftplugin = "setlocal fo< com< tw< commentstring<"
		\ .. "| unlet b:match_ignorecase b:match_words b:match_skip"
<
Применение команды ":setlocal" для параметра с символом '<' после его
наименования, позволяет вернуть параметру его глобальное значение. Это, как
правило, самый лучший способ восстановить значение параметра.

Чтобы отменить действие командного файла для установки отступов, аналогичным
образом установить переменную «b:undo_indent».

Обе эти переменные используют синтаксис предыдущей версии языка
программирования, а не новый синтаксис |Vim9|.

Для этого способа требуется, чтобы в значении параметра 'cpoptions'
отсутствовал флага 'C', это необходимо для функциональности продолжение строк.


НАИМЕНОВАНИЕ ФАЙЛА

Тип файла должен быть указан в наименовании файла модуля, см. |ftplugin-name|.
Допускается использование одной из трёх форм:

    .../ftplugin/stuff.vim ~
    .../ftplugin/stuff_foo.vim ~
    .../ftplugin/stuff/bar.vim ~

здесь «stuff» обозначает тип файла, а «foo» и «bar» это произвольные названия.


РАСПОЗНАВАНИЕ ТИПА ФАЙЛА				*plugin-filetype*

Если имеется файл, тип которого ещё не распознаётся редактором Vim, то в
таком случае следует создать в отдельном командном файле программный код
определения типа файла. Обычно это специальная автокоманда, которая задаёт тип
файла при обнаружении совпадения шаблона с наименованием файла. Например,
>
	au BufNewFile,BufRead *.foo		setlocal filetype=foofoo
<
Поместите этот однострочный командный файл как «ftdetect/foofoo.vim» в первый
каталог из списка значений параметра 'runtimepath'. В UNIX-подобных системах
полный маршрут может быть таким «~/.vim/ftdetect/foofoo.vim».  Соглашение
предписывает, что в качестве наименования командного файла следует указывать
название типа файла.

При желании могут быть выполнять и более сложные проверки в программном коде
на уточнение типа файла, например, проверка содержимого файла для определения
языка программирования, на котором он написан. См. также |new-filetype|.


РЕЗЮМЕ							*ftplugin-special*

Перечислим уникальные элементы, которые используются в модулях типа файла:

<LocalLeader>		Значение переменной «maplocalleader», с помощью
			которой пользователь определяет клавиши, с которых
			начинаются клавиатурные команды для модулей типа файла.

map <buffer>		Определить локальную для данного буфера клавиатурную
			команду.

noremap <script>	Разрешение переопределения только тех клавиатурных
			команды, которые в модуле начинаются с <SID>.

setlocal		Установка параметров только для текущего буфера.

command -buffer		Определение пользовательских команд локально только для
			данного буфера.

exists("*s:Func")	Проверка существования данной функции.

См. также |plugin-special| для получения информации об элементах, которые
применяются во всех модулях.

==============================================================================
*51.3*	Создание модуля для компилятора		*write-compiler-plugin*

В модуле для компилятора выполняется настройка параметров применимых только к
определённым компилятором. Пользователь загружает такой модуль при помощи
команды |:compiler|. Его основное предназначение состоит в настройке значений
параметров 'errorformat' и 'makeprg'.

Проще всего показать это на примере. Это команда, которая позволяет
редактировать все стандартные модули для компиляторов:
>
        next $VIMRUNTIME/compiler/*.vim
<
Для перехода к следующему модулю воспользуйтесь командой |:next|.

Эти модули имеют две особенности. Во-первых, механизм, с помощью которого
пользователь может переопределять или добавлять значения к используемому по
умолчанию файлу. В модулях, которые применяются по умолчанию, в самом начале
выполняются следующие команды:
>
	vim9script
	if exists("g:current_compiler")
	  finish
	endif
	g:current_compiler = "mine"
<
Если будет создан свой командный файл для компилятора и размещён в личном
каталоге для этих модулей (в UNIX-подобных системах это, например,
«~/.vim/compiler»), то в этом файле потребуется установить переменную
«current_compiler», чтобы не загружался модуль, используемый для данного
компилятора по умолчанию.
							*:CompilerSet*
Второй механизм заключается в применении команды ":set" при исполнении команд
":compiler!" и ":setlocal" во время исполнения команды ":compiler".
В редакторе Vim определена для этого пользовательская команда ":CompilerSet".
Приведём пример.
>
  CompilerSet errorformat&		" use the default 'errorformat'
  CompilerSet makeprg=nmake
<

Используйте описанный выше механизм при написании модулей для компилятора,
используемых по умолчанию в системе или распространяемых в комплекте поставки
редактора Vim. Если пользователь определит переменную «current_compiler» в
собственном модуле, то системный модуль считываться не будет.

Если собственный модуль для компилятора предназначен только, чтобы изменить
некоторые настройки модуля, который используется по умолчанию, то не следует
проверять в нём значение переменной «current_compiler». Такой модуль будет
загружаться в последнюю очередь, поэтому он должен находиться в каталоге,
который указан в списке значений параметра 'runtimepath' в самом конце.
В UNIX-подобных системах это может быть «~/.vim/after/compiler».

==============================================================================
*51.4*	Распространение модулей для редактора Vim	*distribute-script*

Пользователи редактора Vim, как правило, ищут полезные и нужные для работы
модули на веб‐странице Vim http://www.vim.org
Если созданный модуль может быть полезен для других, поделитесь этим модулем!

Ещё одним полезным местом для модулей редактора Vim является портал
https://github.com 
Но здесь нужно знать, где можно найти нужный модуль.
Преимущество портала https://github.com в том, что большинство создателей и
сопровождающих модулей для редактора Vim загружают их именно на портал github.
Чтобы найти требуемый модуль, потребуется воспользоваться поисковой системой.

Большинство модулей редактора Vim можно использовать в любой операционной
системе. Но вот инструментов tar или gzip может и не оказаться в какой‐то
конкретной системе. Именно поэтому рекомендуется использовать инструмент zip
для сжатия и архивирования командных файлов для редактора Vim.

Для обеспечения максимальной переносимости модулей между различными системами,
используйте сам редактор Vim для объединения командных файлов. Делается это
при помощи встроенного инструмента Vimball. Подробности см. здесь — |vimball|.

Хорошим тоном считается добавление возможности автоматического обновления
модулей. См. здесь — |gvis-plugins|.

==============================================================================

Следующая глава «Создание крупных подключаемых модулей, |usr_52.txt|.
Об авторских правах на документацию см. |manual-copyright|.

© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

 vim:tw=78:ts=8:ft=help:norl:

