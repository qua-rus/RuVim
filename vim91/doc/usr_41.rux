*usr_41.txt*	       для Vim version 9.1	  редакция от 23 сен 2024 г.

		  РУКОВОДСТВО ПОЛЬЗОВАТЕЛЯ ПО РЕДАКТОРУ VIM
			      автор Брам Моленар

		       Встроенный язык программирования


Встроенный язык программирования редактора Vim применяется в файле
инициализации «vimrc», в правилах распознавания синтаксиса редактируемых
файлов и во многих других областях работы программы Vim. В этой главе
объясняются детали использования этого языка и она будет несколько больше
остальных, так как возможности языка весьма значительны.

|41.1|	Введение
|41.2|	Переменные
|41.3|	Выражения
|41.4|	Операторы проверки условия
|41.5|	Вычисление выражений
|41.6|	Применение функций
|41.7|	Определение функции
|41.8|	Списки и словари
|41.9|	Пробельные символы в командных файлах
|41.10|	Продолжение строки в программах VimL
|41.11|	Комментарии в командных файлах
|41.12|	Формат командных файлов

 Следующая глава «Создание и изменение пунктов меню», |usr_42.txt|.
Предыдущая глава «Составные команды», |usr_40.txt|.
      Содержание, |usr_toc.txt|.

==============================================================================
*41.1*	Введение				*vim-script-intro*  *script*

Давайте начнём с терминологии. Командный файл Vim (также скрипт Vim) — это
любой файл, который редактор Vim может обработать и исполнить. Сюда входят
файлы, написанные на языке программирования Vim (язык сценариев Vim),
например, файлы с расширением .vim или файлы конфигурации, такие как «.vimrc»
и «.gvimrc». Эти командные файлы могут содержать функции, команды и настройки,
которые редактор Vim использует для изменения и расширения своего функционала.

Немного злоупотребляя терминологией, мы будем использовать слова «скрипт Vim»
или «командный файл Vim» для обозначения языка программирования редактора Vim
во всей этой документации. Это сокращение поможет упростить объяснение и
обсуждение работы с командными файлами в редакторе Vim.

Подключаемый модуль Vim — это набор из одного или нескольких командных файлов
Vim, а также дополнительных файлов, таких как справочная документация, файлы
конфигурации и другие ресурсы, предназначенные для расширения определённых
свойств или функциональных возможностей в редакторе Vim. Подключаемый модуль
может добавлять новые команды, расширять существующий функционал, а также
интегрировать внешние инструменты или службы в среду редактора Vim.

Первое знакомство с языком программирования Vim (также называемый VimL)
происходит при создании файла инициализации «vimrc», который считывается в
процессе запуска редактора Vim. В этом файле, например, можно настроить
необходимые параметры редактора Vim, определить клавиатурный команды, указать
необходимые для запуска подключаемые модули и прочее. Вообще в этом файле
можно использовать любые команды, начинающиеся с символа двоеточия, также
называемые командами Ex-режима или командами командной строки.

Командными файлами на языке программирования Vim являются также файлы с
описанием правил распознавания синтаксиса редактируемого текста, и файлы,
которые задают определённые параметры редактора в зависимости от типа
открытого файла. В отдельном командном файле можно описать какие‐то сложные
макропоследовательности. Можно перечислять ещё множество различных полезных
применений для языка программирования Vim.

Лучший способ проверить, что такое язык программирования Vim — создать
командный файл и запустить его на исполнение.
В общем случае это выглядит так:
>
	:edit test.vim
	[набираем необходимые строки скрипта]
	:w
	:source %
<
Начнём с простого примера
>
	vim9script
	var i = 1
	while i < 5
	  echo "счётчик равен" i
	  i += 1
	endwhile
<
Результат выполнения этих команд будет таким:

    счётчик равен 1 ~
    счётчик равен 2 ~
    счётчик равен 3 ~
    счётчик равен 4 ~

В первой строке приведённого выше примера команда `vim9script` указывает, что
этот командный файл использует новый язык программирования |Vim9|. Это важно
для того, чтобы редактор Vim знал как обрабатывать следующие строки. Поэтому
настоятельно рекомендуется указывать эту команду самой первой, перед любыми
другими строками с комментариями и командами.
							*vim9-declarations*
По команде `var i = 1` выполняется объявление переменной «i» и начальное
присвоение значения. Общий синтаксис этой команды такой:
>
	var {переменная} = {выражение}
<
В данном случае наименованием переменной является буква «i», а выражением —
просто число 1.
Далее по команде ":while" открывается цикл. Общий формат этой команды такой:
>
	while {условие}
	  {выражения}
	endwhile
<
Выражения, указанные до соответствующей команды ":endwhile", выполняются до
тех пор, пока условие является истинным. В нашем примере в качестве условия
используется выражение "i < 5", и оно является истинным пока значение
переменной i меньше 5.
    Совет.
    Если «посчастливилось» написать цикл, который выполняется бесконечно,
    то прервать его можно нажатием комбинации клавиш CTRL-C (CTRL+Break в
    системе MS Windows).

По команде ":echo" будет выведено то, что передано этой команде в качестве
аргументов. В нашем случае аргументами этой команды являются строка «счётчик
равен» и значение переменной i. Поскольку i равняется единице, то будет
выведено сообщение

    счётчик равен 1 ~

Затем следует команда `i += 1` . По этой команде будет выдан аналогичный
результат что и по команде "i = i + 1", но она немного быстрее при
наборе. Значение переменной i суммируется с 1 и полученный результат
присваивается той же самой переменной i.

Данный пример приведён для объяснения принципов работы команд языка VimL, но
если действительно требуется написать подобный цикл, это можно сделать куда
как более компактно
>
	for i in range(1,4)
	   echo $"счётчик равен {i}"
	endfor
<
В этой главе нет подробного описания команды |:for|, `$"stirng"` и функции
|range()|, а приводится оно в другой части документации. Если интересно это
узнать прямо сейчас, то перейдите по указанным ссылкам.


ПРОВЕРКА РАБОТЫ ПРИМЕРОВ

Можно проверить работу большинства примеров из документации без необходимости
перепечатывания и сохранения их в отдельном файле. Например, чтобы проверить
как работает цикл `for`, приведённый выше, сделайте следующее:
1. Установите каретку на строку с командой `for`;
2. Переключите редактор в визуальный режим по команде `v`;
3. Переместите каретку на строку с командой `endfor`;
4. Нажмите клавишу с символом двоеточие, наберите в командной строке "so"
    и нажмите клавишу <ENTER>.

После нажатия клавиши с символом двоеточие, в командной строке будет
отображаться ":'<,'>", что означает диапазон выделенного текста.

Некоторые команды необходимо выполнять только в контексте языка |Vim9|. Но,
как правило, для набранных в командной строке команд используется синтаксис
предыдущей версии языка. Это можно увидеть в примере, находящемся ниже,
который вызывает ошибку E1004. Для того, чтобы этого избежать, четвёртый шаг,
который приведён выше, должен выглядеть так:
4. Нажмите клавишу с символом двоеточие, наберите в командной строке "vim9 so"
    и нажмите клавишу <ENTER>.

Здесь «vim9» — это сокращение для команды `vim9cmd` которая указывает, что
следующие команды должны обрабатываться по правилам версии языка |Vim9|.

Обратите внимание, что приведённые выше шаги не будут применимы для примеров,
в которых требуется работа только в контексте командных файлов.


ЧЕТЫРЕ ВИДА ЧИСЕЛ

Числа, используемые в языке VimL, могут быть десятичными, шестнадцатеричными,
восьмеричными и двоичными.

Для шестнадцатеричных чисел используется приставка «0x» или «0X». Например,
шестнадцатеричное число 0x1f — это десятичное число 31, а 0x1234 — десятичное
4660.

Для восьмеричных чисел используется приставка «0o» или «0O». Восьмеричное
число 0o17 — это десятичное 15.

Для двоичных чисел используется приставка «0b» или «0B». Например, двоичное
число 0b101 — это десятичное число 5.

Для десятичных чисел нет никаких приставок и число 10 — это просто число 10.
Будьте внимательны, и не указывайте для десятичных чисел ведущий ноль. Если
поместить 0 перед десятичным числом, то такое число будет восприниматься как
восьмеричное в предыдущей версии языке VimL! Это ещё одна из причин, почему
надо использовать новую версию |Vim9| языка программирования Vim.

По команде ":echo" всегда выводятся десятичные числа. Например,
>
	echo 0x7f 036
<    127 30 ~

Число может быть отрицательным, если перед ним указан знак минус. Это также
относится к шестнадцатеричными и восьмеричными числами:
>
	echo -0x7f
<    -127 ~

Также знак минус используется для операции вычитания. Иногда это может
привести к путанице. Например, в следующем примере будет выведена ошибка, если
мы укажем знак минус перед обеим числами:
>
	echo -0x7f -0o36
<    E1004: Требуется пробельный символ перед и после '-' в "-0o36" ~

Примечание. Если для этого примере не используется |Vim9| и он набран
непосредственно в командной строке, то будут использованы правила разбора
выражений, применяемые в предыдущей версии языка. В этом случае в команде
`echo` второй знак минус будет обрабатываться как операция вычитания. Чтобы
увидеть сообщение об ошибке, добавьте команду `vim9cmd` перед другими
командами:
>
	vim9cmd echo -0x7f -0o36
<    E1004: Требуется пробельный символ перед и после '-' в "-0o36" ~

Пробел внутри выражения требуются для облегчения понимания и исключения ошибок.
Например, может показаться что "-0o36" это запись отрицательного числа,
в то время как на сам деле в выражении выполняется операция вычитания.

Для того чтобы действительно знак минус указывал, что число отрицательное,
можно заключить такое выражение в круглые скобки:
>
	echo -0x7f (-0o36)
<    -127 -30 ~

==============================================================================
*41.2*	Переменные

Наименование переменной может состоять из букв кодировки ASCII, цифр и символа
подчёркивания. Наименование не может начинаться с цифры. Вот примеры
допустимого именования переменных:

	counter
	_aap3
	very_long_variable_name_with_underscores
	CamelCaseName
	LENGTH

Недопустимыми наименованиями являются:

	foo.bar
	6var

Для некоторых переменных действует глобальная область видимости. Чтобы
просмотреть существующие глобальные переменные, воспользуйтесь командой
>
	:let
<
Глобальные переменные могут применяться повсеместно. Но это также приводит,
как минимум, к путанице, а как максимум, может вызвать и серьёзные осложнения,
если одно и тоже наименование переменной используется в несвязанных командных
файлах. Поэтому переменные, объявленные в командном файле, являются локальными
для этого скрипта. Например, если в командном файле «script1.vim» есть такой
код:
>
	vim9script
	var counter = 5
	echo counter
<    5 ~

И если указать эту же переменную в командном файле «script2.vim» как показано
ниже, то получим сообщение об ошибке:
>
	vim9script
	echo counter
<    E121: Отсутствует определение переменной counter ~

Использование локальной переменной скрипта означает, что она может быть
изменена только в этом же скрипте, а не где-либо ещё.

Если необходимо использовать какую‐то переменную в нескольких командных
файлах, добавьте приставку «g:» к её наименованию и присвойте значение
напрямую, а не через команду `:var`. Выбирайте для таких переменных особое
название, чтобы избежать ошибок. Таким образом получается следующее:
>
	vim9script
	g:mash_counter = 5
	echo g:mash_counter
<    5 ~

И тогда для командного файла «script2.vim»: >

	vim9script
	echo g:mash_counter
<    5 ~

Доступ к глобальным переменным можно также получить и из командной строки
редактора. Например, наберите следующую команду
>
	echo g:mash_counter
<
Но это не будет работать для локальных переменных скриптов.

Подробнее о локальных переменных см. в разделе |script-variable|.

Существуют также и другие виды переменных, см. |internal-variables|.
Наиболее часто употребляются следующие:

	b:name		локальная переменная по отношению к буферу;
	w:name		локальная переменная по отношению к окну;
	g:name		глобальная переменная (в том числе внутри функции);
	v:name		переменная, предопределённая в программе Vim.


УДАЛЕНИЕ ПЕРЕМЕННЫХ

Назначенные переменные занимают память и всегда отображаются в выводе команды
":let". Чтобы удалить глобальную переменную, используйте команду ":unlet".
Например,
>
	unlet g:counter
<
По этой команде выполняется удаление глобальной переменной «g:counter» и
освобождается занимаемая ей память. Если нет уверенности, существует ли
переменная с таким наименование, и нежелательно получать сообщение об ошибке в
том случае, если такой переменной не существует, то добавьте к команде
модификатор !
>
	unlet! g:counter
<
Удаление локальных переменных не поддерживается в версии языка |Vim9|, это
можно сделать только в программах предыдущей версии языка.

По окончанию исполнения программы, объявленные в ней локальные переменные
не будут удалены. Это позволяет определённым в этой программе функциям
повторно использовать такие переменные. Пример.
>
	vim9script
	var counter = 0
	def g:GetCount(): number
	  counter += 1
	  return counter
	enddef
<
Теперь при каждом вызове этой функции, она будет возвращать новое значение
переменной «counter»:
>
	:echo g:GetCount()
<    1 ~
>
	:echo g:GetCount()
<    2 ~

Если беспокоит, что какая‐то локальная переменная занимает много памяти,
присвойте ей пустое или нулевое значение после того, как она больше не нужна.
Пример.
>
	var lines = readfile(...)
	...
	lines = []
<
Примечание. Далее мы не будет указывать строку «vim9script» в примерах, чтобы
сосредоточиться на других командах, но не забывайте помещать эту строку в
начало командных файлов.


СТРОКОВЫЕ ПЕРЕМЕННЫЕ И КОНСТАНТЫ

До сих пор мы использовали в качестве значения переменной только числа.
Однако, можно использовать также и строки (текст). В программе Vim числа и
строки являются базовыми типами данных. Пример.
>
	var name = "Петя"
	echo name
<    Петя ~

Каждая переменная относится к какому‐то типу данных. Очень часто, как в данном
примере, тип определяется путём присвоения значения. Это называется
подразумеваемый тип (или вывод типа). Если при объявлении переменной не
выполняется её инициализация данными, то требуется указать тип этой переменной.
>
	var name: string
	var age: number
	if male
	   name = "Петя"
	   age = 42
	else
	   name = "Лиза"
	   age = 45
	endif

Если при присвоении значения переменной будет использован несоответствующий
тип данные, то будет выведено сообщение об ошибке:
>
	age = "Петя"
<    E1012: Несоответствующий тип данных. Ожидался number, а получен string ~

Подробнее о типах говорится в параграфе |41.8|.

Чтобы присвоить строковое значение переменной, необходимо указать строковую
константу. Строковые константы бывают двух видов. Во-первых, это строки в
двойных кавычках, как мы делали выше. Если необходимо использовать двойную
кавычку внутри строки, то её требуется экранировать при помощи символа
обратной наклонной черты
>
	var name = Его имя "\"Петя\""
	:echo name
<    Его имя "Петя" ~

Чтобы избежать необходимости указывать обратную наклонную черту, можно
воспользоваться строками в одинарных кавычках
>
	:let name = 'Его имя "Петя"'
	:echo name
<    Его имя "Петя" ~

В строке, заключённой в одинарные кавычки, все символы передаются как есть.
Как следствие, внутрь такой строки невозможно поместить символ одинарной
кавычки. Чтобы в строке использовать одинарную кавычку, такую строку надо
заключать в двойные кавычки. Обратная наклонная черта в такой строке также
воспринимается буквально и не может быть использована для экранирования
символа одинарной кавычки или какого угодно другого символа. Пример.
>
	var name = 'П\е''тя'''
	echo name
<    П\е'тя' ~

В строках заключённых в двойные кавычки можно использовать различные
специальные символы. Вот несколько наиболее полезных:

	\t		<Tab>, табуляция
	\n		<NL>, разрыв строки
	\r		<CR>, перевод каретки
	\e		<ESC>
	\b		<BS>, удаление символа слева от каретки
	\"		"
	\\		\, обратная наклонная черта
	\<Esc>		<ESC>
	\<C-W>		CTRL-W

Последние два примера показывают как можно использовать форму "\<клавиша>"
для включения в строку специальных клавиш.

Полный перечень специальных символов в строках см. в параграфе |expr-quote|.

==============================================================================
*41.3*	Выражения

В программе Vim используется довольно стандартный способ обработки выражений.
Подробное описание этих возможностей можно найти в параграфе
|expression-syntax|. Здесь же покажем наиболее общие принципы работы.

Числа, строки и переменные сами по себе являются выражениями. Поэтому
везде, где требуется использование выражений, также может быть использованы
числа, строки или переменные. Другими базовыми элементами, которые могут быть
использованы в качестве выражений, являются:

	$NAME		переменная окружения;
	&name		параметр;
	@r		регистр.

В качестве примера:
>
	echo "Значение параметра 'tabstop':" &ts
	echo "Ваш домашний каталог:" $HOME
	if @a == 'text'
<
Форма &name может также быть использована для сохранения значения параметра,
установки нового значение и восстановления старого значения после выполнения
ряда операций. Пример.
>
	var save_ic = &ic
	set noic
	s/Начало/Исток/
	&ic = save_ic
<
Этот пример позволяет убедиться, что поиск по шаблону "Начало" применяется в
регистронезависимом режиме, со сброшенным параметром 'ignorecase'. И уже после
выполнения команды поиска восстанавливается прежнее значение этого параметра.
(Другим способом выполнить такой поиск является добавление флага "\C" к
шаблону, подробности см. в описании |/\C|).


МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ

Описанные элементы можно сочетать, и тогда это становится действительно
интересно! Попробуем для начала заняться арифметикой с числами:

	a + b		сложение;
	a - b		вычитание;
	a * b		умножение;
	a / b		целочисленное деление;
	a % b		взятие остатка от деления.

Используется обычный приоритет операций. Пример.
>
	echo 10 + 5 * 2
<    20 ~

Части выражения можно группировать при помощи круглых скобок. Тоже никаких
сюрпризов. Пример.

>
	echo (10 + 5) * 2
<    30 ~


ПРОЧИЕ

Строки можно соединять с помощью операции ".." (две точки, см. |expr6|). Пример.
>
	echo "лом" .. "бард"
<    ломбард ~

Если команда ":echo" используется с несколькими аргументами, то при выводе они
разделяются пробелом. А в только что приведённом примере всего один аргумент,
выражение соединения (конкатенация), поэтому пробел не будет вставлен.

Также для строк можно использовать операцию интерполяции (преобразования),
форма записи которой $"строка", и принимает выражение в фигурных скобках
>
	echo $"Имя: {name}"
<
Подробнее см. в параграфе |interpolated-string|.

Из языка программирования Си заимствована условная тернарная операция
>
	a ? b : c
<
Если выражение «a» вычисляется как истинное, то возвращаемым значением
является «b», в ином случае значением является «c». Пример.
>
	var nr = 4
	echo nr > 5 ? "nr больше" : "nr меньше"
<    nr меньше ~

В условном выражении всегда прежде всего выясняется значение его составных
частей, т. е.:

	(a) ? (b) : (c)

Также доступен оператор нулевого слияния. Пример.
 >
	echo name ?? "Имя не указано"
<
Подробнее см. описание оператора |??|.

==============================================================================
*41.4*	Операторы проверки условия

По команде ":if" выполняются последующие выражения, пока не встретится
сопоставленная ей команда ":endif", только в том случае, когда условие
выполняется. Общая форма записи:

	if {условие}
	  {выражения}
	endif

Указанные {выражения} будут выполняться только в том случае, если значением
{условие} является истина (не ноль). Выражения, конечно, должны быть
допустимыми командами. Если в них имеются ошибки, то не будет обнаружена
соответствующая команда ":endif".

Также  может быть использована команда ":else". Общая форма записи:

	if {условие}
	  {выражения}
	else
	  {выражения}
	endif

Указанные {выражения} после команды ":else" будут выполняться только в том
случае, если не выполняются выражения после команды ":if".

Кроме того, также есть ещё команда ":elseif".

	if {условие}
	  {выражения}
	elseif {условие}
	  {выражения}
	endif

Принцип работы точно такой же, как если бы мы использовали команду ":else" и
затем команду ":if", но в данном случае не требуется указание дополнительной
команды ":endif".

Полезный пример для файла «vimrc» — проверка значения параметра 'term' и
выполнение операций в зависимости от этого значения.
>
	if &term == "xterm"
	  # Выполнить команды, применимые к терминалу xterm
	elseif &term == "vt100"
	  # Выполнить команды, применимые к терминалу vt100
	else
	  # Выполнить команды, применимые к другим терминалам
	endif
<
Здесь символ «#» означает начало комментария, об этом будет рассказано далее.


ЛОГИЧЕСКИЕ ОПЕРАЦИИ

Мы уже использовали некоторые логические операции в ранее приведённых примерах.
Вот наиболее полезные из них:

	a == b		эквивалентно;
	a != b		не эквивалентно;
	a >  b		больше чем;
	a >= b		больше или равно;
	a <  b		меньше чем;
	a <= b		меньше или равно.

Если условие выполняется, то результатом будет значение true (истина), иначе
результатом будет false (ложь). Пример.
>
	if v:version >= 800
	  echo "Примите поздравления!"
	else
	  echo "У вас слишком старая версия, обновите программу!"
	endif
<
В данном случае используется предопределённая в редакторе Vim переменная,
значение которой равно номеру версии редактора. В версии 8.0 значением
переменной "v:version" является 800, в версии 8.1 — 801. Это полезно при
написании программ, которые работают в разных версиях программы Vim. Описание
см. |v:version|. С помощью функции |has()| можно проверить наличие включённых
в программу компонентов или исправлений, см. параграф |has-patch|.

Логические операторы можно употреблять как с числами, так и со строками. При
сравнении двух строк используется математическая разность. При этом
сравниваются значения байт, что может быть некорректно для некоторых языков.

При сравнении строки с числом будет выведено сообщение об ошибке.

Для строк возможны ещё две операции:

	str =~ pat	совпадает;
	str !~ pat	не совпадает.

Левый операнд выражения, "str", рассматривается как строка, а правый операнд
"pat", применяется как шаблон, такой же шаблон, как и для команды поиска.
Пример.
>
	if str =~ " "
	  echo "в str встречается пробел"
 	endif
	if str !~ '\.$'
 	  echo "str не заканчивается символом точка"
	endif
<
Обратите внимание на использование строки в одинарных кавычках для шаблона.
Это может быть полезным, поскольку в строке в двойных кавычках пришлось бы
дублировать обратную наклонную черту, а в шаблонах часто встречается символ
обратной наклонной черты.

При сравнении не учитываются начальная и конечная позиция строки. Если
требуется сопоставить всю строку целиком, используйте якорные метасимволы:
для начальной позиции символ «^», а для конечной — «$».

При выполнении сравнения строк не учитывается значение параметра 'ignorecase'.
Если требуется игнорирование регистра, добавьте флаг флаг "?". Таким образом,
при указании оператора "==?" проверяется эквивалентность строки без оценки
регистра символов. Полную таблицу возможных комбинаций см. в параграфе
|expr-==|.


ПРИМЕНЕНИЕ В ЦИКЛАХ

Команда ":while" уже описывалась ранее. И в дополнении укажем, что в теле
этого цикла между командами ":while" и ":endwhile" могут быть использованы ещё
две дополнительных команды:

	continue		Возврат на начало цикла ":while" и продолжение
				цикла.
	break			Переход к команде ":endwhile" и прекращение
				цикла.

Пример.
>
	var counter = 1
	while counter < 40
	  if skip_number(counter)
	    continue
	  endif
	  if last_number(counter)
	    break
	  endif
	  sleep 50m
	  ++counter
	endwhile
<
По команде ":sleep" приостанавливается программа Vim. Значение «50m» задаёт
остановку на 50 миллисекунд, а по команде `sleep 4` устанавливается пауза в
четыре секунды.

Команды `continue` и `break` могут быть указаны между командами `for` и `endfor`.
Также циклы могут быть заданы по команде ":for", см. далее в параграфе |41.8|.

==============================================================================
*41.5*	Вычисление выражений

В приведённых выше примерах команды в программах выполнялись редактором Vim
напрямую. А в тоже время посредством команды ":execute" представляется очень
мощное средство для построения и выполнения команд: она позволяет использовать
результаты выражения.

Например, если требуется перейти к индексу, определённому в переменной, то
>
	execute "tag " .. tag_name

Мы используем оператор ".." для соединения строки «tag » со значением
переменной «tag_name». Если переменная «tag_name» содержит значение «get_cmd»,
то будет выполнена команда
>
	tag get_cmd
<
По команде ":execute" допускается выполнять только Ex-команды. По команде
":normal" выполняются команды режима команд. Но аргументы этой команды
являются не выражения, а буквальные символы, из которых состоит команда.
Пример.
>
	normal gg=G
<
По этой команде будет выполнено перемещение каретки в первую строку по команде
"gg" и форматирование всех строк в тексте заданное оператором `=` с перемещением
каретки в конец текста по команде "G".

Чтобы для команды ":normal" можно было использовать выражения в качестве
аргументов, используйте её в комбинации с командой ":execute". Пример.
>
	execute "normal " .. count .. "j"
<
При исполнении этой команды будет выполнено перемещение каретки на «count»
строк вниз.

Убедитесь, что аргументы команды ":normal" это полностью законченная
команда. В противном случае, программа Vim обработав всю строку аргументов
прервёт исполнение команды без каких‐либо сообщений. Например, если указан
оператор удаления, то должна быть указана и команда перемещения или текстовый
объект. Это будет выполнено
>
	normal d$
<
А в этом случае ничего не произойдёт
>
	normal d
<
В частности, если выполнено переключение в режим вставки, но он не был
завершён нажатием клавиши <ESC>, то будет выполнено его автоматическое
завершение.
Например, это сработает для вставки текста «новый текст»
>
	execute "normal iновый текст"
<
Если после вставки текста предполагаются ещё какие‐то действия, то нужно явно
указать выход из режима вставки
>
	execute "normal iновый текст\<Esc>b"
<
По этой команде выполняется вставка слов «новый текст» в текущей строке и
перемещение каретки на первую букву слова «текст».
Обратите внимание на использование символов "\<Esc>" для симуляции нажатия
специальной клавиши. Это позволяет избежать непосредственной вставки символа
«esc» в текст программы. Вот как раз для таких случаев и требуется команда
`execute` с аргументом в виде строки в двойных кавычках.

В случае когда не требуется исполнение строкового выражения как команды,
но необходимо вычислить его значение, можно использовать встроенную функцию
|eval()|. Пример.
>
	var optname = "path"
	var optvalue = eval('&' .. optname)
<
Здесь символ «&» объединяется со значением «path» и аргументом функции будет
строка «&path». В результате будет получено значение параметра 'path'.

==============================================================================
*41.6*	Применение функций

В редакторе Vim имеется множество встроенных функций, позволяющих существенно
расширить его функциональность. И в этой главе будет дано несколько таких
примеров. Полный перечень встроенных функций дан ниже, см. |function-list|.

При вызове функция её параметры указываются внутри круглых скобок и
разделяются запятыми. Например,
>
	search("Дата: ", "W")
<
По этой команде будет вызвана функция search(), с аргументами «Дата: » и «W».
Первый аргумент используется функцией search() в качестве шаблона для поиска,
а второй аргумент устанавливает флаги поиска. Флаг «W» указывает, что поиск
не должен продолжаться с начала файла по достижению окончания файла.

Применение команды ":call" при вызове функции не обязательно при использовании
версии |Vim9| языка программирования Vim, но является обязательным для
предыдущей версии языка и в командной строке.
>
	call search("Дата: ", "W")
<
Также функцию можно вызывать как выражение. Пример.
>
	var line = getline(".")
	var repl = substitute(line, '\a', "*", "g")
	setline(".", repl)
<
Здесь при вызове функции getline() будет получено содержание строки из
текущего буфера. Её аргументом является номер строки, которую надо считать.
В данном случае используется псевдоним «.», что означает строка, в которой
находится каретка.

Действие функции substitute() похоже на действие по команде ":substitute".
Первым аргументом «line» передаётся строка, в которой выполняется замена.
Второй аргумент «\a» задаёт шаблон поиска, третьим аргументом «*» задаётся
текст замены, а последним аргументом «g» — флаг.

Через вызов функции setline() выполняется замена строки, на которую
указывает первый аргумент, текстом, заданным вторым аргументом. В этом примере
строка под кареткой заменяется на результат выполнения функции |substitute()|.
Таким образом, наш программынй код делает то же самое, что и команда
>
	:substitute/\a/*/g
<
Использование функций становится более интересным, если до и после вызова
функции |substitute()| происходит дополнительная обработка.


ФУНКЦИИ							*function-list*

Как уже говорилось, в программе Vim реализовано множество встроенных функций.
Далее приводится перечень этих функций, сгруппированный по их назначению.
Алфавитный перечень можно посмотреть в главе |builtin-function-list|. Нажмите
комбинацию клавиш CTRL-] на наименовании функции, чтобы перейти к её
подробному описанию.


Операции со строками:					*string-functions*
	nr2char()	получить символ по его числовому коду;
	list2str()	получить строку символов из списка числовых кодов;
	char2nr()	получить числовой код символа;
	str2list()	получить список числовых кодов из строки символов;
	str2nr()	преобразовать строку в тип Number;
	str2float()	преобразовать строку в тип Float;
	printf()	форматировать строку по заданным %‐шаблонам;
	escape()	экранировать символы в строке с помощью '\';
	shellescape()	экранировать строку для применения в командной
			оболочке;
	fnameescape()	экранировать наименование файла для применения
			в командах редактора Vim;
	tr()		замена одних символов на другие;
	strtrans()	преобразовать строку в печатный вид;
	keytrans()	преобразовать внутренние представление кодов клавиш
			в форму, используемую в команде ":map";
	tolower()	преобразовать символы строки в строчные буквы;
	toupper()	преобразовать символы строки в прописные буквы;
	charclass()	получить класс символа;
	match()		начальная позиция совпадения с шаблоном;
	matchbufline()	получить все совпадения с шаблоном в текущем буфере;
	matchend()	конечная позиция совпадения с шаблоном;
	matchfuzzy()	приблизительно совпавшая строка в списке строк;
	matchfuzzypos()	позиция приблизительно совпавшей строки в списке строк;
	matchstr()	получить из строки подстроку совпадающую с шаблоном;
	matchstrlist()	получить все совпадения с шаблоном в списке строк;
	matchstrpos()	подстрока и её позиция в строке совпадающая с шаблоном;
	matchlist()	как matchstr(), но также возвращающая список совпадений;
	stridx()	первая позиция совпадения подстроки в строке;
	strridx()	последняя позиция совпадения подстроки в строке;
	strlen()	получить длину строки в байтах;
	strcharlen()	получить длину строки в символах;
	strchars()	получить количество символов в строке;
	strutf16len()	количество кодовых позиций UFT-16 в строке;
	strwidth()	получить размер строки на экране;
	strdisplaywidth() получить размер строки на экране с учётом табуляции;
	setcellwidths()	переопределить ширину знакоместа на экране;
	getcellwidths()	получить переопределённую ширину знакоместа;
	reverse()	изменить порядок символов строке;
	substitute()	заменить совпадения с шаблоном заданной строкой;
	submatch()	найти подходящий шаблон в ":substitute" и substitute();
	strpart()	получить часть строки по номеру байта;
	strcharpart()	получить часть строки по номеру символа;
	slice()		получить по номеру символа диапазон из строки в Vim9;
	strgetchar()	получить символ из строки по номеру символа;
	expand()	заменить специальные символы на их значение;
	expandcmd()	заменить специальные символы для Ex-команд;
	iconv()		перекодировать текст из одной кодировки в другую;
	byteidx()	получить номер байта символа в строке;
	byteidxcomp()	как byteidx(), но количество в составных символах;
	charidx()	получить номер символа в строке по номеру байта;
	utf16idx()	получить номер символа в строке по номеру байта UTF-16;
	repeat()	повторить строку заданное количество раз;
	eval()		вычислить значение строкового выражения;
	execute()	исполнить Ex-команду и получить результат;
	win_execute()	как execute(), но для указанного окна;
	trim()		вырезать символы из строки;
	bindtextdomain() установить базовый маршрут поиска переведённых строк;
	gettext()	поиск переведённых строк сообщений.

Операции с данными типа List:				*list-functions*
	get()		получить элемент списка без выдачи ошибки при его
			отсутствии;
	len()		получить количество элементов в списке;
	empty()		проверить есть ли элементы в списке;
	insert()	вставить элемент в любое место списка;
	add()		добавить элемент в список;
	extend()	расширить список;
	extendnew()	создать список и добавить элемент;
	remove()	убрать один или несколько элементов из списка;
	copy()		создать простую копию списка;
	deepcopy()	создать полную копию списка;
	filter()	убрать выбранные элементы из списка;
	map()		изменить каждый элемент в списке;
	mapnew()	создать новый список с изменёнными элементами;
	foreach()	применить функцию к каждому элементу списка;
	reduce()	преобразовать список к значению;
	slice()		получить диапазон элементов из списка;
	sort()		сортировать список;
	reverse()	изменить порядок элементов в списке на обратный;
	uniq()		убрать одинаковые повторяющиеся элементы из списка;
	split()		разбить строку на список символов;
	join()		объединить элементы списка в строку;
	range()		получить список из заданного количества элементов;
	string()	представить список в виде строки;
	call()		вызвать функцию со списком аргументов;
	index()		получить индекс элемента в списке или типе данных BLOB;
	indexof()	получить индекс элемента в списке или типе данных BLOB,
			значение выражения которых является истинным;
	max()		получить максимальное значение в списке;
	min()		получить минимальное значение в списке;
	count()		подсчитать сколько раз значение появляется в списке;
	repeat()	повторить список заданное количество раз;
	flatten()	уменьшить количество вложенных списков;
	flattennew()	уменьшить количество вложенных списков создав новый.

Операции с данными типа Dictionary:			*dict-functions*
	get()		получить запись словаря без выдачи ошибки при её
			отсутствии;
	len()		получить количество записей в словаре;
	has_key()	проверить есть ли ключ в словаре;
	empty()		проверить есть ли записи в словаре;
	remove()	убрать запись из словаря;
	extend()	добавить записи из одного словаря в другой;
	extendnew()	создать словарь и добавить элемент;
	filter()	убрать выбранные записи из словаря;
	map()		изменить каждую запись в словаре;
	mapnew()	создать новый словарь с изменёнными записями;
	foreach()	применить функцию к каждому элементу словаря;
	keys()		получить список ключей словаря;
	values()	получить список значений словаря;
	items()		получить список пар ключей и значений;
	copy()		создать простую копию словаря;
	deepcopy()	создать полную копию словаря;
	string()	представить словарь в виде строки;
	max()		получить максимальное значение в словаре;
	min()		получить минимальное значение в словаре;
	count()		подсчитать сколько раз значение появляется в словаре.

Вычисления чисел с плавающей запятой:			*float-functions*
	float2nr()	преобразовать тип Float в тип Number;
	abs()		получить абсолютно значение (также применимо для типа
			Number);
	round()		вычислить с округлением до ближайшего целого;
	ceil()		вычислить с округлением вверх до ближайшего целого;
	floor()		вычислить с округлением вниз до ближайшего целого;
	trunc()		убрать дробную часть после десятичной запятой;
	fmod()		получить остаток от деления;
	exp()		вычислить экспоненту заданного числа;
	log()		вычислить натуральный логарифм (по основанию e);
	log10()		вычислить десятичный логарифм (по основанию 10);
	pow()		возвести значение x в степень y;
	sqrt()		вычислить квадратный корень;
	sin()		вычислить синус;
	cos()		вычислить косинус;
	tan()		вычислить тангенс;
	asin()		вычислить арксинус;
	acos()		вычислить арккосинус;
	atan()		вычислить арктангенс;
	atan2()		вычислить арктангенс;
	sinh()		вычислить гиперболический синус;
	cosh()		вычислить гиперболический косинус;
	tanh()		вычислить гиперболический тангенс;
	isinf()		проверить на конечность числа;
	isnan()		проверить на нечисловое значение.

Операции с данными типа BLOB:				*blob-functions*
	blob2list()	преобразовать тип BLOB в список чисел;
	list2blob()	преобразовать список чисел в тип BLOB;
	reverse()	изменить порядок чисел на обратный.

Прочие вычисления:					*bitwise-function*
	and()		бинарная операция логического «И»;
	invert()	бинарная операция логического «НЕ» (инверсия);
	or()		бинарная операция логического «ИЛИ»;
	xor()		бинарная операция логического исключающего «ИЛИ»;
	sha256()	получить контрольное число по алгоритму SHA-256;
	rand()		получить псевдослучайное число;
	srand()		инициализация генератора псевдослучайных чисел.

Для работы с переменные:				*var-functions*
	instanceof()	проверить, является ли переменная экземпляром данного
			класса;
	type()		получить тип переменной как числовое значение;
	typename()	получить тип переменной как словесное описание;
	islocked()	проверить состояние блокировки переменной;
	funcref()	получить тип Funcref по ссылки на функции;
	function()	получить тип Funcref по наименованию функции;
	getbufvar()	получить значение переменной для указанного буфера;
	setbufvar()	задать переменную для указанного буфера;
	getwinvar()	получить переменную для указанного окна;
	setwinvar()	задать переменную для указанного окна;
	gettabvar()	получить переменную для указанной вкладки;
	settabvar()	задать переменную для указанной вкладки;
	gettabwinvar()	получить переменную для указанных окна и вкладки;
	settabwinvar()	задать переменную для указанных окна и вкладки;
	garbagecollect() попробовать освободить память.

					*cursor-functions*  *mark-functions*
Обработка местоположения каретки и закладок:
	col()		номер колонки для каретки или закладки;
	virtcol()	экранная колонка для каретки или закладки;
	line()		номер строки для каретки или закладки;
	wincol()	относительный номер колонки каретки в видимом окне;
	winline()	относительный номер строки каретки в видимом окне;
	cursor()	установить каретку в заданную строку и колонку;
	screencol()	получить номер колонки каретки на экране;
	screenrow()	получить номер строки каретки на экране;
	screenpos()	номер строки и колонки символа текста на экране;
	virtcol2col()	получить индекс в байтах для символа текста на экране;
	getcurpos()	получить местоположение каретки;
	getpos()	получить местоположение каретки, закладки и т. п.;
	setpos()	установить каретку, закладку и т. п.;
	getmarklist()	получить перечень локальных и глобальных закладок;
	byte2line()	получить номер строки по номеру байта;
	line2byte()	номер байта в определённой строке;
	diff_filler()	получить количество отфильтрованных строк выше строки;
	screenattr()	получить атрибут строки и колонки на экране;
	screenchar()	получить код символа в экранной строке и колонке;
	screenchars()	получить коды символа в экранной строке и колонке;
	screenstring()	получить строку символов в экранной строке и колонке;
	charcol()	номер символа в позиции каретки или закладки;
	getcharpos()	получить символ в позиции каретки, закладки, и т. п.;
	setcharpos()	установить каретку, закладку и т. п. в позицию символа;
	getcursorcharpos() получить номер символа в позиции каретки;
	setcursorcharpos() установить каретку по номеру символа.

Для работы с текстом в текущем буфере:			*text-functions*
	getline()	получить содержимое строки или списка строк из буфера;
	getregion()	получить область текста из буфера;
	getregionpos()	получить список координат области текста;
	setline()	заменить содержимое строки в текущем буфере;
	append()	добавить строку или список строк под указанной строкой;
	indent()	установить отступ для указанной строки;
	cindent()	установить отступ согласно правилам в языке Си;
	lispindent()	установить отступ согласно правилам в языке Lisp;
	nextnonblank()	найти следующую непустую строку;
	prevnonblank()	найти предыдущую непустую строку;
	search()	найти строку в которой есть совпадение с шаблоном;
	searchpos()	найти позицию в строке которая совпадает с шаблоном;
	searchcount()	получить количество совпадений перед и после каретки;
	searchpair()	найти соответствующий парный элемент;
	searchpairpos()	найти позицию соответствующего парного элемента;
	searchdecl()	найти место объявления переменной;
	getcharsearch()	получить информацию о методе поиска одиночного символа;
	setcharsearch()	задать информацию о методе поиска одиночного символа.

Для работы с текстом в другом буфере:
	getbufline()	получить список строк из указанного буфера;
	getbufoneline()	получить одну строку из указанного буфера;
	setbufline()	заменить строку в указанном буфере;
	appendbufline()	добавить список строк в указанных буфер;
	deletebufline()	удалить строки из указанного буфера.

					*system-functions*  *file-functions*
Для взаимодействия с ОС и операций с файлами:
	glob()		развернуть шаблонные символы в наименованиях файлов;
	globpath()	развернуть шаблонны символы в наименованиях маршрутов;
	glob2regpat()	преобразовать шаблонные символы в шаблоны поиска;
	findfile()	найти файл в перечисленных каталогах;
	finddir()	найти каталог в перечисленных каталогах;
	resolve()	найти файл, на который указывает ссылка;
	fnamemodify()	видоизменить наименование файла;
	pathshorten()	сократить наименования каталогов в маршруте к файлу;
	simplify()	упростить маршрут без изменения расположения файла;
	executable()	проверить существование исполняемого файла;
	exepath()	полный маршрут к исполняемому файлу;
	filereadable()	проверить возможность чтения из файла;
 	filewritable()	проверить возможность записи в файл;
	getfperm()	получить разрешения для файла;
	setfperm()	установить разрешения для файла;
	getftype()	получить тип файла;
	isabsolutepath() проверить, является ли маршрут абсолютным;
	isdirectory()	проверить существование каталога;
	getfsize()	получить размер файла;
	getcwd()	получить наименование текущего рабочего каталога;
	haslocaldir()	проверить используемый рабочий каталог окна;
	tempname()	получить наименование временного файла;
	mkdir()		создать каталог;
	chdir()		изменить текущий рабочий каталог;
	delete()	удалить файл;
	rename()	переименовать файл;
	system()	получить результат выполнения команды командной
			оболочки в виде текста;
	systemlist()	получить результат выполнения команды командной
			оболочки в виде списка;
	environ()	получить значение всех переменных окружения;
	getenv()	получить значение указанной переменной окружения;
	setenv()	установить значение переменной окружения;
	hostname()	название машины на которой запущена программа Vim;
	readfile()	получить содержимое файла в виде списка строк;
	readblob()	получить содержимое файла в виде двоичных данных;
	readdir()	получить список файлов и подкаталогов указанного
			каталога;
	readdirex()	получить информацию о файлах и подкаталогах указанного
			каталога;
	writefile()	записать список строк или двоичных данных в файл;
	filecopy()	копировать файл {из} {в}.

Для работы с датой и временем:		*date-functions*  *time-functions*
	getftime()	получить время последнего изменения файла;
	localtime()	получить текущее время в секундах;
	strftime()	представить число секунд в виде строкового формата
			даты и времени;
	strptime()	представить строковый формат даты и временем в виде
			числа секунд;
	reltime()	получить точное текущее время или прошедшее за
			определённый отрезок;
	reltimestr()	представить результат функции reltime() как строку;
	reltimefloat()	представить результат функции reltime() как число с
			плавающей запятой.

Для работы с автокомандами:				*autocmd-functions*
	autocmd_add()	добавить перечень автокоманд и групп;
	autocmd_delete() убрать перечень автокоманд и групп;
	autocmd_get()	получить перечень автокоманд.

			*buffer-functions*  *window-functions*  *arg-functions*
Для работы с буферами, окнами и списком редактируемых файлов:
	argc()		количество элементов в списке файлов‐аргументов;
	argidx()	текущая позиция в списке файлов‐аргументов;
	arglistid()	получить идентификатор списка файлов‐аргументов;
	argv()		получить элемент из списка файлов‐аргументов;
	bufadd()	добавить файл в список буферов;
	bufexists()	проверить существование буфера;
	buflisted()	проверить существование буфера и его присутствие в
			списке буферов;
	bufload()	обеспечить загрузку буфера;
	bufloaded()	проверить существование и загрузку буфера;
	bufname()	получить наименование указанного буфера;
	bufnr()		получить номер указанного буфера;
	tabpagebuflist() получить список буферов во вкладке;
	tabpagenr()	получить номер вкладки;
	tabpagewinnr()	как функция winnr(), но для указанной вкладки;
	winnr()		получить номер текущего окна;
	bufwinid()	получить идентификатор окна для указанного буфера;
	bufwinnr()	получить номер окна для указанного буфера;
	winbufnr()	получить номер буфера для указанного окна;
	listener_add()	добавить функцию обработчик изменений в буфере;
	istener_flush() вызвать функции обработчик изменений в буфере;
	listener_remove() убрать функцию обработчик изменений в буфере;
	win_findbuf()	получить идентификаторы окон, в которых отображается
			заданный буфер;
	win_getid()	получить идентификатор указанного окна;
	win_gettype()	получить тип указанного окна;
	win_gotoid()	переместить каретку в окно с указанным идентификатором;
	win_id2tabwin()	получить номер вкладки и окна по идентификатору окна;
	win_id2win()	получить номер окна по идентификатору окна;
	win_move_separator() переместить вертикальный разделитель окна;
	win_move_statusline() переместить строку состояния окна;
	win_splitmove()	переместить окно, создав новый раскрой окон;
	getbufinfo()	получить информацию о буфере в виде списка;
	gettabinfo()	получить информацию о вкладке в виде списка;
	getwininfo()	получить информацию об окне в виде списка;
	getchangelist()	получить список корректировок;
	getjumplist()	получить список переходов;
	swapfilelist()	перечень существующих файлов подкачки в 'directory';
	swapinfo()	получить информацию о файле подкачки;
	swapname()	получить расположение файла подкачки указанного буфера.

Для работы с командной строкой:			*command-line-functions*
	getcmdcompltype() вид используемой подстановки в командной строке;
	getcmdline()	получить содержимое ввода командной строки;
	getcmdprompt()	получить результат функций запроса командной строки;
	getcmdpos()	получить позицию каретки в командной строке;
	getcmdscreenpos() видимая позиция каретки в командной строке;
	setcmdline()	поместить в строку содержимое командной строки;
	setcmdpos()	установить карету в заданную позицию командной строки;
	getcmdtype()	получить тип командной строки;
	getcmdwintype()	получить тип окна командной строки;
	getcompletion()	список вариантов подстановки в командной строке;
	fullcommand()	получить полное наименование команды.

Для работы с общим и локальным списком результатов:	*quickfix-functions*
	getqflist()	получить перечень записей в списке результатов;
	setqflist()	изменить содержимое списка результатов;
	getloclist()	перечень записей в локальном списке результатов;
	setloclist()	изменить содержимое локального списка результатов.

Для работы с подстановкой в режиме вставки:		*completion-functions*
	complete()	задать список вариантов;
	complete_add()	добавить элемент в список вариантов;
	complete_check() проверить необходимость остановки поиска подстановки;
	complete_info()	получить информацию о текущей подстановке;
	pumvisible()	проверить отображается ли всплывающее меню;
	pum_getpos()	позиция и размер отображаемого всплывающего меню.

Для работы со структурой текста:			*folding-functions*
	foldclosed()	проверить наличие указанной строки в свёрнутом блоке;
	foldclosedend() как foldclosed(), но возвращает номер последней строки
			блока структуры;
	foldlevel()	получить уровень вложенных блоков для заданной строки;
	foldtext()	установить текст, отображаемый в строке со свёрнутым
			блоком структуры;
	foldtextresult() получить текст, отображаемый в строке со свёрнутым
			блоком структуры.

				*syntax-functions*  *highlighting-functions*
Для разбора синтаксиса и подсветки текста:
	clearmatches()	сбросить все заданные назначения, определённые в
			функции |matchadd()| и командой |:match|;
	getmatches()	получить все заданные назначения, определённые в
			функции |matchadd()| и командой |:match|;
	hlexists()	проверить существование группы подсветки;
	hlget()		получить атрибуты группы подсветки;
	hlset()		установить атрибуты группы подсветки;
	hlID()		получить идентификатор группы подсветки;
	synID()		получить идентификатор группы синтаксиса;
	synIDattr()	получить заданный атрибут идентификатора синтаксиса;
	synIDtrans()	получить преобразованное в идентификатор синтаксиса
			заданное значение;
	synstack()	получить перечень идентификаторов синтаксиса для
			заданной позиции текста;
	synconcealed()	получить информацию о способе скрытия текста;
	diff_hlID()	получить идентификатор подсветки в режиме сверки для
			заданной позиции;
	matchadd()	назначить подсветку для текста, совпадающего
			с заданным шаблоном;
	matchaddpos()	назначить подсветку для текста в заданной позиции;
	matcharg()	получить информацию о параметрах команды |:match|;
	matchdelete()	удалить назначения заданные функцией |matchadd()| или
			командой |:match|;
	setmatches()	восстановить назначения, полученные через функцию
			|getmatches()|.

Для проверки правописания:				*spell-functions*
	spellbadword()	получить слова с ошибкой начиная с позиции каретки;
	spellsuggest()	получить варианты написания для слова с ошибкой;
	soundfold()	поучить омофоны для заданного слова.

Для работы с журналами:					*history-functions*
	histadd()	добавить запись в указанный журнал;
	histdel()	удалить запись из указанного журнала;
	histget()	получить запись из указанного журнала;
	histnr()	получить количество записей в указанном журнале.

Для взаимодействие с пользователем:			*interactive-functions*
	browse()	вызвать диалоговое окно выбора файла;
	browsedir()	вызвать диалоговое окно выбора каталога;
	confirm()	предложить пользователю выбор;
	getchar()	получить код набранного пользователем символа;
	getcharstr()	получить набранный пользователем символ в виде строки;
	getcharmod()	получить модификатор последнего набранного символа;
	getmousepos()	получить последнюю позицию указателя «мышь»;
	getmouseshape()	получить название вида указателя «мышь»;
	echoraw()	передать символы как есть;
	feedkeys()	поместить символы в упреждающий буфер ввода;
	input()		получить набранную пользователем строку;
	inputlist()	получить выбранный пользователем пункт из
			представленного списка;
	inputsecret()	получить набранную строку без отображения на экране;
	inputdialog()	получить набранную в диалоговом окне строку;
 	inputsave()	сохранить и очистить упреждающий буфер ввода;
 	inputrestore()	восстановить содержимое упреждающего буфера ввода.

Для работы с графическим интерфейсом:				*gui-functions*
	getfontname()	получить наименование используемого шрифта;
	getwinpos()	получить позицию окна программы Vim;
	getwinposx()	получить горизонтальные координаты окна программы Vim;
	getwinposy()	получить вертикальные координаты окна программы Vim;
	balloon_show()	установить текст, отображаемый во всплывающей выноске;
	balloon_split()	разбить на строки отображаемое во всплывающей выноске
			сообщение;
	balloon_gettext() получить отображаемый во всплывающей выноске текст.

Для работы с Vim-сервером:				*server-functions*
	serverlist()	получить перечень наименований серверов;
	remote_startserver() запустить сервер;
	remote_send()	передать команду на Vim-сервер;
	remote_expr()	вычислить выражение на Vim-сервере;
	server2client()	отправить ответ клиенту Vim-сервера;
	remote_peek()	проверить существование ответа от Vim-сервера;
	remote_read()	прочитать ответ Vim-сервера;
	foreground()	переместить окно программы Vim на передний план;
	remote_foreground() переместить окно Vim-сервера на передний план.

Для работы с размером и позицией окна:			*window-size-functions*
	winheight()	получить высоту указанного окна;
	winwidth()	получить ширину указанного окна;
	win_screenpos()	получить отображаемую позицию окна;
	winlayout()	получить расположение окон во вкладке;
	winrestcmd()	вернуть команду для восстановления размеров окна;
	winsaveview()	получить информацию об отображение окна;
	winrestview()	восстановить отображение окна из сохранённой информации.

Для работы с клавиатурными командами и меню:		*mapping-functions*
	digraph_get()	получить диграф;
	digraph_getlist() получить все диграфы;
	digraph_set()	установить диграф;
	digraph_setlist() установить несколько диграфов;
	hasmapto()	проверить существование клавиатурной команды по
			выполняемому действию;
	mapcheck()	проверить существование клавиатурной команды по
			клавише клавиатуры;
	maparg()	получить выполняемое действие клавиатурной команды;
	maplist()	получить перечень всех клавиатурных команд;
	mapset()	восстановить выполняемое действие клавиатурной команды;
	menu_info()	получить информацию по пункту меню;
	wildmenumode()	проверить текущий режим меню подстановки.

Для диагностики:					*test-functions*
	assert_equal()		проверить эквивалентности значений двух
				выражений;
	assert_equalfile()	проверить эквивалентность содержимого двух
				файлов;
	assert_notequal()	проверить не эквивалентность значений двух
				выражений;
	assert_inrange()	проверить нахождение значения выражения в
				пределах заданного диапазона;
	assert_match()		проверить соответствие шаблона значению;
	assert_notmatch()	проверить не соответствие шаблона значению;
	assert_false()		проверить, что результат выражения является
				ложным;
	assert_true()		проверить, что результат выражения является
				истинным;
	assert_exception()	проверить возникновение исключительной
				ситуации для команды;
	assert_beeps()		проверить подачу звукового оповещение при
				исполнении команды;
	assert_nobeep()		проверить отсутствие звукового оповещения при
				исполнении команды;
	assert_fails()		проверить возникновение ошибки при исполнении
				команды;
	assert_report()		проверить возникновение ошибки при диагностики;
	test_alloc_fail()	инициировать сбой при выделении памяти;
	test_autochdir()	установить параметр 'autochdir' в процессе
				запуска программы;
	test_override()		тестировать c изменённым поведением внутренних
				функций программы Vim;
	test_garbagecollect_now() немедленная очистка памяти;
	test_garbagecollect_soon() установить флаг последующей очистки памяти;
	test_getvalue()		получить значение внутренних переменных
				программы;
	test_gui_event()	генерировать события ГИП для диагностики;
	test_ignore_error()	игнорировать заданное сообщение об ошибке;
	test_mswin_event()	генерировать события для MS Windows;
	test_null_blob()	получить нулевое значение данных тип BLOB;
	test_null_channel()	получить нулевое значение данных тип Chanel;
	test_null_dict()	получить нулевое значение данных тип Dictionary;
	test_null_function()	получить нулевое значение данных тип Funcref;
	test_null_job()		получить нулевое значение данных тип Job;
	test_null_list()	получить нулевое значение данных тип List;
	test_null_partial()	получить нулевое значение функции частичного
				применения;
	test_null_string()	получить нулевое значение данных тип String;
	test_settime()		установить время для внутреннего применения
				программой;
	test_setmouse()		установить позицию указателя «мышь»;
	test_feedinput()	поместить в буфер ввода строку символов;
	test_option_not_set()	сбросить флаг указывающий установку параметра;
	test_scrollbar()	имитировать движение полосы прокрутки в ГИП;
	test_refcount()		получить начальное значение выражения;
	test_srand_seed()	установить начальное значение для функции
				srand();
	test_unknown()		получить значение данных с неизвестным типом;
	test_void()		получить значение данных с пустым типом;

Для обработки межпроцессорного взаимодействия:		*channel-functions*
	ch_canread()	проверить наличие данных для считывания;
	ch_open()	открыть канал связи;
	ch_close()	закрыть канал связи;
	ch_close_in()	закрыть входящий канал связи;
	ch_read()	считать сообщение из канала связи;
	ch_readblob()	считать двоичные данные из канала связи;
	ch_readraw()	считать сообщение из канала связи без декодирования;
	ch_sendexpr()	передать JSON‐сообщение через канал связи;
	ch_sendraw()	передать сообщение через канал связи без кодирования;
	ch_evalexpr()	передать выражение через канал связи;
	ch_evalraw()	передать строку через канал связи без кодирования;
	ch_status()	получить информацию по состоянию канала связи;
	ch_getbufnr()	получить номер буфера канала связи;
	ch_getjob()	получить связанное с каналом связи задание;
	ch_info()	получить информацию о канале связи;
	ch_log()	записать сообщение в файл журнала канала связи;
	ch_logfile()	задать файл журнала канала связи;
	ch_setoptions()	установить режим канала связи;
	json_encode()	кодировать выражение в JSON‐строку;
	json_decode()	декодировать JSON-строку в поддерживаемые программой
			Vim данные;
	js_encode()	кодировать выражение в JSON‐строку;
	js_decode()	декодировать JSON-строку в поддерживаемые программой
			Vim данные;
	err_teapot()	генерация ошибки номер 418 или 503.

Для обработки заданий:					*job-functions*
	job_start()	запустить выполнение задания;
	job_stop()	остановить выполнение задания;
	job_status()	получить информацию по состоянию задания;
	job_getchannel() получить канал, используемый заданием;
	job_info()	получить информацию о задании;
	job_setoptions() установить параметры задания.

Для работы со значками:					*sign-functions*
	sign_define()	назначить или изменить атрибуты значка;
	sign_getdefined() получить перечень назначенных значков;
	sign_getplaced() получить места установки значков;
	sign_jump()	перейти к значку;
	sign_place()	разместить значок;
	sign_placelist() разместить значки;
	sign_undefine()	удалить назначенные значки;
	sign_unplace()	убрать значок;
	sign_unplacelist() убрать значки.

Для работы с окном терминала:				*terminal-functions*
	term_start()	открыть окно терминала и запустить в нём задание;
	term_list()	получить перечень буферов терминала;
	term_sendkeys()	отправить на терминал коды клавиш клавиатуры;
	term_wait()	установить время ожидания обновления экрана;
	term_getjob()	получить связанное с терминалом задание;
	term_scrape()	получить содержание экранной строки терминала;
	term_getline()	получить текстовую строку из терминала;
	term_getattr()	получить значение заданного атрибута;
	term_getcursor() получить позицию каретки в терминале;
	term_getscrolled() получить размер буфера экрана терминала;
	term_getaltscreen() получить флаг использования альтернативного экрана;
	term_getsize()	получить размер терминала;
	term_getstatus() получить информацию о статусе терминала;
	term_gettitle()	получить строку заголовка терминала;
	term_gettty()	получить наименование псевдотерминала;
	term_setansicolors() установить цвета из 16‐цветной палитры, для ГИП;
	term_getansicolors() получить цвета из 16‐цветной палитры, для ГИП;
	term_dumpdiff()	показать различия между двумя сохранёнными снимками
			экрана терминала;
	term_dumpload()	открыть сохранённый в файл снимок экрана терминала;
	term_dumpwrite() записать в файл снимок экрана терминала;
	term_setkill()	установить сигнал остановки задания в терминале;
	term_setrestore() установить команду для восстановления терминала;
	term_setsize()	установить размер терминала;
	term_setapi()	установить префикс наименования функции JSON API.

Для работы со всплывающими окнами:		*popup-window-functions*
	popup_create()	создать всплывающее окно в центре экрана;
	popup_atcursor() создать всплывающее окно выше позиции каретки,
			 которое будет закрыто при перемещении каретки;
	popup_beval()	в позиции указанной в переменной v:beval_ и которое
			будет закрыто при перемещении указателя «мышь»;
	popup_notification() показать уведомлении в течении трёх секунд;
	popup_dialog()	создать всплывающее окно в центре экрана с отбивкой и
			рамкой;
	popup_menu()	создать всплывающее окно с вариантами выбора из
			заданного списка;
	popup_hide()	временно скрыть всплывающее окно;
	popup_show()	отобразить ранее скрытое всплывающее окно;
	popup_move()	изменить положение и размер всплывающего окна;
	popup_setoptions() переопределить параметры всплывающего окна;
	popup_settext()	заменить содержимое буфера всплывающего окна;
	popup_setbuf()	установить буфер всплывающего окна;
	popup_close()	закрыть одно всплывающее окно;
	popup_clear()	закрыть все всплывающие окна;
	popup_filter_menu() выбрать элемент из предложенного перечня;
	popup_filter_yesno() заблокировать до нажатия клавиши с символом «y»
			     или «n»;
	popup_getoptions() получить текущие параметры всплывающего окна;
	popup_getpos()	получить реальное положение и размер всплывающего окна;
	popup_findecho() получить идентификатор всплывающего окна,
			 используемого командой ":echowindow";
	popup_findinfo() получить идентификатор информационного всплывающего
			 окна;
	popup_findpreview() получить идентификатор всплывающего окна просмотра;
	popup_list()	получить перечень всех всплывающих окон;
	popup_locate()	получить идентификатор всплывающего окна в заданной
			позиции экрана.

Для работы с таймерами:					*timer-functions*
	timer_start()	создать таймер;
	timer_pause()	приостановить или возобновить работу таймера;
	timer_stop()	остановить работу таймера;
	timer_stopall()	остановить работу всех таймеров;
	timer_info()	получить информацию об имеющихся таймерах.

Для работы с индексами:					*tag-functions*
	taglist()	получить список соответствующих индексов;
	tagfiles()	получить список файлов с индексами;
	gettagstack()	получить перечень индексов окна;
	settagstack()	изменить перечень индексов окна.

Для работы с буфером запроса:				*promptbuffer-functions*
	prompt_getprompt()    получить результирующий текст из буфера запроса;
	prompt_setcallback()  установить функции обработчик для буфера;
	prompt_setinterrupt() установить функции обработчик прерываний для
			      буфера;
	prompt_setprompt()    установить текст запроса для буфера.

Для работы с регистрами:				*register-functions*
 	getreg()	получить содержимое указанного регистра;
	getreginfo()	получить информацию об указанном регистре;
 	getregtype()	получить тип регистра;
 	setreg()	установить тип и содержимое регистра;
	reg_executing()	получить наименование регистра, в котором начата
			обработка выражений;
	reg_recording()	получить наименование регистра, в который начата
			запись макрокоманды;

Для обработки свойств текста:			*text-property-functions*
	prop_add()	присоединить свойство в заданной позиции текста;
	prop_add_list()	присоединить свойство в нескольких позициях текста;
	prop_clear()	убрать все свойства из заданных строк;
	prop_find()	найти соответствующее свойство текста;
	prop_list()	получить список всех свойств в строке;
	prop_remove()	убрать свойство текста из заданной строки;
	prop_type_add()	задать тип свойства текста;
	prop_type_change() изменить параметр свойства текста заданного типа;
	prop_type_delete() удалить свойство текста заданного типа;
	prop_type_get()	получить параметры свойства текста заданного типа;
	prop_type_list() получить все наименования типов свойства текста.

Для работы со звуком:					*sound-functions*
	sound_clear()	остановить воспроизведение всех звуков;
	sound_playevent() воспроизвести звук заданного системного события;
	sound_playfile() воспроизвести звук из заданного файла;
	sound_stop()	остановить воспроизведение звука.

Прочие:							*various-functions*
	mode()		получить текущий режим редактирования;
	state()		получить текущее состояние;
	visualmode()	получить последний использованный визуальный режим;
	exists()	проверить существование переменной, функции и т. п.;
	exists_compiled() как exists(), но проверяет во время компиляции;
	has()		проверить доступность компонента программы Vim;
	changenr()	получить номер последнего изменения;
	cscope_connection() проверить существование соединения с базой cscope;
	did_filetype()	проверить использование автокоманды FileType;
	diff()		показать разницу между двумя строками;
	eventhandler()	проверить вызов обработчика по событию;
	getpid()	получить идентификатор процесса программы Vim;
	getscriptinfo()	получить перечень загруженных командных файлов Vim;
	getimstatus()	проверить статус активности IME;
	interrupt()	прервать исполнение программы на языке VimL;
	windowsversion() получить версию ОС MS Windows;
	terminalprops()	получить свойства терминала;

	libcall()	вызвать функцию из внешней библиотеки;
	libcallnr()	как libcall(), но с кодом возврата;

	undofile()	получить наименование файла содержащий изменения;
	undotree()	получить состояние «дерева» изменений для буфера;

	shiftwidth()	получить действующее значение параметра 'shiftwidth';

	wordcount()	получить количество байт, слов, символов в буфере;

	id()		получить уникальную строку для указанного элемента;

	luaeval()	вычислить выражение |Lua|;
	mzeval()	вычислить выражение |MzScheme|;
	perleval()	вычислить выражение Perl (|+perl|);
	py3eval()	вычислить выражение Python (|+python3|);
	pyeval()	вычислить выражение Python (|+python|);
	pyxeval()	вычислить выражение |python_x|;
	rubyeval()	вычислить выражение |Ruby|;

	debugbreak()	прервать исполнение программы для диагностики.

==============================================================================
*41.7*	Определение функции

Помимо большого количества встроенных функции в языке программирования Vim
имеется возможность создавать необходимые пользователю функции.
В общем виде объявление функции выглядит так:
>
	def {наименование}({арг1}, {арг2}, ...): тип возвращаемого значения
	  {тело функции}
	enddef
<
    Примечание.
    Наименования функций, определённых пользователем, должны начинаться с
    прописной буквы.

Давайте попробуем определить простую функцию, которая возвращает наименьшее из
двух чисел. Она начинается со строки
>
	def Min(num1: number, num2: number): number
<
Этой командой указывается, что будет определена функция с наименованием «Min»,
для неё требуется два числовых аргумента, — «num1» и «num2», и функция вернёт
числовое значение.

Первое действие, которое требуется выполнить в этой функции, это проверить
какое из чисел меньше
>
	if num1 < num2
<
Что ж, давайте присвоим переменной «smaller» значение наименьшего аргумента
>
	var smaller: number
	if num1 < num2
	  smaller = num1
	else
	  smaller = num2
	endif
<
Переменная «smaller» является локальной по отношению к самой функции. Она
объявлена как число, это позволяет предупредить в случае какой‐либо ошибки.
Все переменные, которые используются внутри функции, являются локальными, за
исключением переменных с приставками, такими как «g:», «w:» или «b:».

    Примечание.
    Чтобы из функции получить доступа к глобальной переменной необходимо
    добавить к её наименованию приставку «g:». Таким образом, запись «g:today»
    в теле функции используется для глобальной переменной «today», а запись
    «today» это уже другая переменная, локальная по отношению к данной функции
    или программе.

Теперь используем команду ":return" для возврата значения наименьшего из двух
чисел. И в заключении требуется завершить определение функции
>
	:  return smaller
	:enddef
<
Всё вместе это выглядит так:
>
	def Min(num1: number, num2: number): number
	  var smaller: number
	  if num1 < num2
	    smaller = num1
	  else
	    smaller = num2
	  endif
	  return smaller
	enddef
<
Эту же функцию можно записать более компактно, не потеряв при этом
функциональность и, возможно, даже выиграв в производительности:
>
	def Min(num1: number, num2: number): number
	  if num1 < num2
	    return num1
	  endif
	  return num2
	enddef
<
Но и эту запись можно сократить. Если вспомнить об операторах проверки
условий, то всё тело функции уместится в одну строку:
>
	def Min(num1: number, num2: number): number
	  return num1 < num2 ? num1 : num2
	enddef
<
Вызов функции, определённой пользователем, ничем не отличается от вызова
встроенной функции. Различие только в наименовании. Функция «Min» может быть
вызвана так:
>
	echo Min(5, 8)
<
Только после этого функция будет передана на исполнение и программа Vim начнёт
обрабатывать её построчно. Если в теле функции допущены ошибки, например,
используется неопределённая переменная или функция, то будет выдано
соответствующее сообщение об ошибке. В момент определении функции такие ошибки
не распознаются.

Чтобы выявить возможные ошибки как можно раньше, поручите программе Vim
скомпилировать все функции в программе. Для этого наберите команду
>
	defcompile
>
Компиляция функций занимает не так уж много времени, но позволяет
заблаговременно обнаруживать возможные ошибки. Рекомендуется указывать команду
":defcompile" в последних строках программы в период работы над ней, и когда
программ будет окончательно готова, просто закомментировать строку с этой
командой.

Для тех функций, которые ничего не возвращают (процедуры), не указывается тип
возвращаемого значения.

Если функция может возвращать любой тип значения, указывается тип «any».

Для определения функций, используемых в предыдущей версии языка, применяют
команды ":function" и ":endfuction". Для таких функций не указывается тип
возвращаемого значения. Также эти функции не могут быть скомпилированы,
поэтому они выполняются несколько медленнее, чем функции из новой версии языка.


ОБРАБОТКА ДИАПАЗОНА СТРОК

При вызове функции возможно указание диапазона строк. В этом случае функция
будет вызвана для каждой отдельной строки из диапазона, с перемещением каретки
в очередную обрабатываемую строку диапазона. Например,
>
	def  Number()
	  echo "строка " .. line(".") .. " содержит: " . getline(".")
	enddef
<
Если вызвать эту функцию так
>
	:10,15Number()
<
то функция будет выполнена 6 раз, начиная со строки номер 10 и закончит
выполнение в строке номер 15.


ПЕРЕЧЕНЬ ФУНКЦИЙ

По команде ":function" будет показан перечень всех функций, не являющихся
встроенными, с их наименованиями и аргументами.
>
	:function
<    def <SNR>86_Show(start: stirng, ...items: list<string>) ~
    function GetVimIndent() ~
    function SetSyn(name) ~

Здесь приставка «<SNR>» означает, что функция является локальной для скрипта.
Функции версии |Vim9| языка будут начинаться с команды "def" и включают типы
аргументов и возвращаемых данных. Функции предыдущей версии языка начинаются
с команды "function".

Чтобы просмотреть определение функции, укажите её наименование в качестве
аргумента для команды ":function".
>
	:function SetSyn
<    function SetSyn(name) ~
   1   if &syntax == '' ~
   2     let &syntax = a:name ~
   3   endif ~
    endfunction ~

Чтобы просмотреть определение функции «Show» требуется указать приставку
«<SNR>», так как может быть несколько функций с названием «Show» в разных
программах. Чтобы посмотреть точное название, используйте команду ":function",
но возможно, что перечень будет очень большой.
Чтобы получить только ту функцию, которая соответствует шаблону, воспользуйтесь
командой ":filter"
>
	:filter Show function
<    def <SNR>86_Show(start: string, ...items: list<string>) ~
>
	:function <SNR>86_Show
<    1  echohl Title ~
    2  echo "start is " .. start ~
	и т. д.


ДИАГНОСТИКА РАБОТЫ ФУНКЦИЙ

Отображаемые номера строк могут оказаться полезным при диагностики работы или
при получении сообщения об ошибке. Подробнее о режиме диагностики рассказано
в параграфе |debug-scripts|.

Также можно для параметра 'verbose' задать значение 12 или большее, чтобы
отслеживать все вызовы функций. При значении 15 и более будет показана каждая
выполняемая строка.


УДАЛЕНИЕ ФУНКЦИИ

Чтобы удалить функцию SetSyn(), наберите команду
>
	:delfunction SetSyn
<
Удалить можно только глобальные функции и функции, определённые в программах
предыдущей версии языка, это неприменимо для функций, определённых в
программах на языке версии |Vim9|.

Если попытаться удалить несуществующую функцию или которая не может быть
удалена, то будет выдано сообщение об ошибке.


ССЫЛКИ НА ФУНКЦИИ

Иногда может быть полезным иметь переменную, указывающую на ту или иную
функцию и это можно сделать через тип переменных ссылающиеся на функции. Такие
переменные называются «funcref». Пример.
>
	vim9script
	def Right(): string
	  return 'Верно!'
	enddef
	def Wrong(): string
	  return 'Неверно!'
	enddef

	var Afunc = g:result == 1 ? Right : Wrong
	echo Afunc()
<    Неверно! ~

В этом примере предполагается, что переменная «g:result» не равна единице.
Подробности см. в главе |Funcref|.

Обратите внимание, что наименование переменной, содержащей ссылку на функции,
должно начинаться с прописной буквы. В противном случае может быть конфликт с
наименованиями встроенных функций.

ДОПОЛНИТЕЛЬНЫЕ МАТЕРИАЛЫ

О функциях с переменным количеством аргументов рассказано в параграфе |50.2|.

Более подробная информация об определении пользовательских функций даётся в
параграфе |user-function|.

==============================================================================
*41.8*	Списки и словари

До сих пор мы использовали простые типы данных — String и Number (строка и
число). Однако в языке VimL также существует два составных типа — List и
Dictionary (список и словарь).

List (список) — это упорядоченная последовательность элементов. Элементы
списка могут иметь любой тип значения, а значит список может содержать числа,
строки, другие списки или всё это вместе. Чтобы создать список состоящий из
трёх строк, воспользуйтесь следующей командой:
>
	var alist = ['aap', 'noot', 'mies']
<
Элементы списка помещаются в квадратные скобки и отделяются друг от друга
запятой. Чтобы создать пустой список, воспользуйтесь командой
>
	var alist = []
<
Чтобы выполнить добавление элементов в список, воспользуйтесь функцией add()
>
	var alist = []
	add(alist, 'foo')
	add(alist, 'bar')
	echo alist
<    ['foo', 'bar'] ~

Также можно соединять списки друг с другом, используя оператор +
>
	var alist = ['foo', 'bar']
	alist = alist + ['and', 'more']
	echo alist
<    ['foo', 'bar', 'and', 'more'] ~

Либо расширять список с помощью функции `extend()`
>
	var alist = ['one']
	extend(alist, ['two', 'three'])
	echo alist
<    ['one', 'two', 'three'] ~

Заметьте, что при использовании функции |add()| в вышеприведённом примере,
результат будет совсем иным по сравнению с функцией |extend()|:
>
	var alist = ['one']
	add(alist, ['two', 'three'])
	echo alist
<    ['one', ['two', 'three']] ~

Как видите, второй аргумент функции `add()` будет добавлен в список как
неделимый элемент и он стал вложенным списком.


ИСПОЛЬЗОВАНИЕ ЦИКЛА ДЛЯ ПЕРЕБОРА ЭЛЕМЕНТОВ

Одна из замечательных вещей, которую можно делать с типом данных List это
перебор всех его элементов:
>
	var alist = ['one', 'two', 'three']
	for n in alist
	  echo n
	endfor
<    one ~
    two ~
    three ~

В приведённом примере будут получены все элементы из переменной с типом List
и значение каждого элемента назначено переменной «n». Общий формат цикла `for`
следующий:
>
	for {переменная} in {список}
	  {команды}
	endfor
<
Чтобы выполнить цикл определённое количество раз, требуется указать длину
списка. Функция range() как раз предназначена для этого:
>
	for a in range(3)
	  echo a
	endfor
<    0 ~
    1 ~
    2 ~

Обратите внимание, что первый элемент списка, который создаётся посредством
функции range(), равен нулю, поэтому последний элемент на единицу меньше длины
списка.
Некоторые пояснения. Внутренняя функция range(), при указании в цикле
`for`, на самом деле не создаёт список, так что большое значение диапазона не
влияет на производительность. При использовании функции range() в любом другом
месте будет создаваться реальный список и обработка большого значения диапазона
занимает определённое время.

Также можно указать максимальное значение, шаг и даже обратный порядок:
>
	for a in range(8, 4, -2)
	  echo a
	endfor
<    8 ~
    6 ~
    4 ~

Более полезный пример — циклический обход всех строк в буфере:
>
	for line in getline(1, 50)
	  if line =~ "Date: "
	    echo line
	  endif
	endfor
<
Будут просмотрены строки с 1 по 50 (включительно) и если в строке есть слово
«Date: », то эти строки будут показаны.


СЛОВАРИ

Dictionary (словарь) — это сборник записей, состоящих из пар вида ключ:значение.
Доступа к значению осуществляется на основе ключа. Для создания словаря
используются фигурные скобки.
>
	var uk2nl = {one: 'een', two: 'twee', three: 'drie'}
<
Чтобы найти просмотреть значения записей в словаре, укажите ключ в квадратных
скобках
>
	echo uk2nl['two']
<    twee ~

Если ключ не содержит специальных символов, то для извлечения значения можно
указывать ключ через точку
>
	echo uk2nl.two
<    twee ~

Общая форма определения словаря выглядит следующим образом:
>
	{<key> : <value>, ...}
<
Чтобы создать пустой словарь, не указывайте ключи внутри фигурных скобок
>
	{}
<
Существует множество способов работы со словарями. Для словарей также есть
встроенные функции. Например, можно получить список ключей и выполнить их
перебор
>
	for key in keys(uk2nl)
	  echo key
	endfor
<    three ~
    one ~
    two ~

Как видно из этого примера, ключи не упорядоченны. Можно отсортировать список,
чтобы упорядочить их:
>
	for key in sort(keys(uk2nl))
	  echo key
	endfor
<    one ~
    three ~
    two ~

Но нет возможности восстановить начальный порядок записей. Для этого этого
нужно использовать списки, в которых элементы хранятся в упорядоченной
последовательности.

Дополнительные материалы см. в параграфе |Dictionaries|

==============================================================================
*41.9*	Пробельные символы

Пустые строки в командных файлах разрешены и такие строки пропускаются.
Начальные пробельные символы (пробел и табуляция) при обработке игнорируются,
исключением является конструкция |:let-herdoc| без использования ключевого
слова «trim».
Концевые пробельные символы, как правило, игнорируются, но не всегда.
Например, команда ":map" будет включать завершающий пробел как часть команды.
Такие ситуации нужно учитывать, в противном случае это может привести к
труднообъяснимым ошибкам. Общие рекомендации — всегда удалять концевые
пробелы, если только они не требуются для работы команды.
Для включения пробельного символа как значения параметра, он должен быть
экранирован символом '\' (обратная наклонная черта), как в следующем примере:
>
	:set tags=мой\ классный\ файл
<
Если это набрать как
>
	:set tags=мой классный файл

то это приведёт к ошибке, поскольку будет обработано таким образом
>
	:set tags=мой
	:set классный
	:set файл
<
Синтаксис новой версии языка |Vim9| очень требователен к пробельным символам.
Это было сделано намеренно, чтобы предотвратить многие ошибки и сделать текст
программ легкочитаемым. Если следовать рекомендациям и разумно использовать
пробелы, то всё будет работать нормально. Если этому не следовать, то будут
выдаваться сообщения об ошибках, с указанием где недостаёт пробела или где его
наоборот нужно убрать.

==============================================================================
*41.10*	Продолжение строки

В предыдущей версии языка программирования Vim в качестве символа продолжения
строки является обратная наклонная черта. Этот символ требуется указывать перед
строкой, которая является продолжением предыдущей строки. Например,
>
	let mylist = [
			\ 'one',
			\ 'two',
			\ ]
<
Для того, чтобы такая запись работала и не возникало ошибок, требуется, чтобы
в параметре 'cpo' был сброшен флаг 'C'. Обычно это делается путём установки
этого параметра в самом начале командного файла:
>
	let s:save_cpo = &cpo
	set cpo&vim
<
И восстановление прежнего значения в конце командного файла:
>
	let &cpo = s:save_cpo
	unlet s:save_cpo
<
Дополнительную информацию можно найти в параграфе |line-continuation|.

В командных файлах, использующих новую версии |Vim9| по‐прежнему можно
применять символ обратной наклонной черты для продолжения строки, но в
большинстве случаев этого не требуется:
>
	var mylist = [
			'one',
			'two',
			]
<
Также не требуется не нужно выполнять манипуляции с параметром 'cpo'.
Детали описаны в параграфе |vim9-line-continuation|.

==============================================================================
*41.11*	Комментарии

В командных файлах |Vim9| используется символ # для указания начала комментария.
Этот символ и всё что следует после него до конца строки считается
комментарием и игнорируется. Однако есть ряд команд, которые не допускают
комментарии и обрабатывают символ комментария, как часть команды, примеры
показаны ниже. Комментарий может начинаться в любой позиции строки, но не
тогда, когда это может быть частью команды, например, внутри строки.

Символ " (двойная кавычка) обозначает начало комментария в предыдущей версии
языка. Это требует определённых усилий, чтобы убедиться, что строки,
заключённые в двойные кавычки, не распознаются как комментарии (ещё одна
причина отдать предпочтение версии |Vim9| языка).

Некоторые команды не допускают комментариев. Примеры: >

	abbrev dev development		# сокращение
	map <F3> o#include		# вставить include
	execute cmd			# выполнить
	!ls *.c				# показать файлы C

‐ Сокращение 'dev' будет преобразовано в 'development     " сокращение'.
‐ В клавиатурной команде для <F3> будет применена вся строка после 'o#....',
  включая и '# вставить include'.
‐ Для команды "execute" будет выведена ошибка.
‐ По команде "!" будет передано командной оболочке всё, что следует после этой
  команды, что приведёт к ошибке командной оболочки.

Комментарии недопустимы после команд ":map", ":abbreviate", ":execute" и
"!", а также ряда других команд. Для команд ":map", ":abbreviate" и ":execute"
можно указать комментарий таким образом:
>
	abbrev dev development|# сокращение
	map <F3> o#include|# вставить include
	execute '!ls *.c'	|# выполнить
<
При помощи символа '|' одна команда отделяется от другой, которой в этом
случае является комментарий. Последний пример с командой ":execute" является
общим решением, такая запись будет работать для всех команд, которые
не допускают комментарий или символ '|' как разделитель команд.

Обратите внимание, что перед символом '|' в командах для назначения сокращения
и клавиатурной команды нет пробела. В этих командах используются все символы,
которые встречаются до символа '|' или конца строки. Как следствие, не всегда
можно увидеть лишние пробелы в этих командах, например,
>
	map <F4> o#include  
<
Здесь это сделано намеренно, в других случаях это может быть случайностью.
Чтобы избежать таких казусов, можно настроить подсветку для концевых пробелов.
>
	match Search /\s\+$/
<
В UNIX-подобных системах есть один специальный способ закомментировать строку,
который позволяет сделать командный файл Vim исполняемым. Этот способ также
будет работать и для предыдущей версии языка VimL.
>
	#!/usr/bin/env vim -S
	echo "this is a Vim script"
	quit
<
==============================================================================
*41.12*	Формат командных файлов

Символ конца строки зависит от операционной системы. Для командных файлов Vim
рекомендуется всегда использовать формат UNIX. В этом случае строки будут
разделяться символом <NL>, и это будет работать в других системах. Так что,
можно перенести командные файлы из MS Windows в UNIX и они продолжат работать.
См. |:source_crnl|. Чтобы убедиться, что формат файла установлен правильно,
наберите эту команду перед записью файла
>
	:setlocal fileformat=unix
<
Если указан формат файла "dos", используется пара символов <CR><LF>. Символ
<CR> может вызвать различные проблемы, лучше не использовать это.

==============================================================================

Расширенная информация о командных файлах Vim дана в главе |usr_50|.

Следующая глава «Создание и изменение пунктов меню», |usr_42.txt|.
Об авторских правах на документацию см. |manual-copyright|.

© Restorer, перевод на русский язык, 2020, <restorer@mail2k.ru>

 vim:tw=78:ts=8:ft=help:norl:
